// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v6.32.0
// source: alkanes.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "alkanes";

export enum AlkanesTraceCallType {
  NONE = 0,
  CALL = 1,
  DELEGATECALL = 2,
  STATICCALL = 3,
  UNRECOGNIZED = -1,
}

export function alkanesTraceCallTypeFromJSON(object: any): AlkanesTraceCallType {
  switch (object) {
    case 0:
    case "NONE":
      return AlkanesTraceCallType.NONE;
    case 1:
    case "CALL":
      return AlkanesTraceCallType.CALL;
    case 2:
    case "DELEGATECALL":
      return AlkanesTraceCallType.DELEGATECALL;
    case 3:
    case "STATICCALL":
      return AlkanesTraceCallType.STATICCALL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AlkanesTraceCallType.UNRECOGNIZED;
  }
}

export function alkanesTraceCallTypeToJSON(object: AlkanesTraceCallType): string {
  switch (object) {
    case AlkanesTraceCallType.NONE:
      return "NONE";
    case AlkanesTraceCallType.CALL:
      return "CALL";
    case AlkanesTraceCallType.DELEGATECALL:
      return "DELEGATECALL";
    case AlkanesTraceCallType.STATICCALL:
      return "STATICCALL";
    case AlkanesTraceCallType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum AlkanesTraceStatusFlag {
  SUCCESS = 0,
  FAILURE = 1,
  UNRECOGNIZED = -1,
}

export function alkanesTraceStatusFlagFromJSON(object: any): AlkanesTraceStatusFlag {
  switch (object) {
    case 0:
    case "SUCCESS":
      return AlkanesTraceStatusFlag.SUCCESS;
    case 1:
    case "FAILURE":
      return AlkanesTraceStatusFlag.FAILURE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AlkanesTraceStatusFlag.UNRECOGNIZED;
  }
}

export function alkanesTraceStatusFlagToJSON(object: AlkanesTraceStatusFlag): string {
  switch (object) {
    case AlkanesTraceStatusFlag.SUCCESS:
      return "SUCCESS";
    case AlkanesTraceStatusFlag.FAILURE:
      return "FAILURE";
    case AlkanesTraceStatusFlag.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface uint128 {
  lo: bigint;
  hi: bigint;
}

export interface AlkaneId {
  block: uint128 | undefined;
  tx: uint128 | undefined;
}

export interface AlkaneTransfer {
  id: AlkaneId | undefined;
  value: uint128 | undefined;
}

export interface MultiSimulateRequest {
  parcels: MessageContextParcel[];
}

export interface MessageContextParcel {
  alkanes: AlkaneTransfer[];
  transaction: Uint8Array;
  block: Uint8Array;
  height: bigint;
  txindex: number;
  calldata: Uint8Array;
  vout: number;
  pointer: number;
  refundPointer: number;
}

export interface KeyValuePair {
  key: Uint8Array;
  value: Uint8Array;
}

export interface ExtendedCallResponse {
  alkanes: AlkaneTransfer[];
  storage: KeyValuePair[];
  data: Uint8Array;
}

export interface Context {
  myself: AlkaneId | undefined;
  caller: AlkaneId | undefined;
  inputs: uint128[];
  vout: number;
  incomingAlkanes: AlkaneTransfer[];
}

export interface TraceContext {
  inner: Context | undefined;
  fuel: bigint;
}

export interface AlkanesEnterContext {
  callType: AlkanesTraceCallType;
  context: TraceContext | undefined;
}

export interface AlkanesExitContext {
  status: AlkanesTraceStatusFlag;
  response: ExtendedCallResponse | undefined;
}

export interface AlkanesCreate {
  newAlkane: AlkaneId | undefined;
}

export interface AlkanesTraceEvent {
  enterContext?: AlkanesEnterContext | undefined;
  exitContext?: AlkanesExitContext | undefined;
  createAlkane?: AlkanesCreate | undefined;
}

export interface AlkanesBlockEvent {
  traces: AlkanesTrace | undefined;
  outpoint: Outpoint | undefined;
  txindex: bigint;
}

export interface AlkanesBlockTraceEvent {
  events: AlkanesBlockEvent[];
}

export interface AlkanesTrace {
  events: AlkanesTraceEvent[];
}

export interface SimulateResponse {
  execution: ExtendedCallResponse | undefined;
  gasUsed: bigint;
  error: string;
}

export interface MultiSimulateResponse {
  responses: SimulateResponse[];
  error: string;
}

export interface AlkaneInventoryRequest {
  id: AlkaneId | undefined;
}

export interface AlkaneIdToOutpointRequest {
  id: AlkaneId | undefined;
}

export interface AlkaneInventoryResponse {
  alkanes: AlkaneTransfer[];
}

export interface AlkaneStorageRequest {
  id: AlkaneId | undefined;
  path: Uint8Array;
}

export interface AlkaneStorageResponse {
  value: Uint8Array;
}

export interface AlkaneIdToOutpointResponse {
  txid: Uint8Array;
  vout: number;
}

export interface Outpoint {
  txid: Uint8Array;
  vout: number;
}

export interface Trace {
  outpoint: Outpoint | undefined;
  trace: AlkanesTrace | undefined;
}

export interface TraceBlockRequest {
  block: bigint;
}

export interface TraceBlockResponse {
  traces: Trace[];
}

export interface BytecodeRequest {
  id: AlkaneId | undefined;
}

export interface BlockRequest {
  height: number;
}

export interface BlockResponse {
  block: Uint8Array;
  height: number;
}

export interface PendingUnwrapsRequest {
  height: number;
}

export interface Payment {
  spendable: Outpoint | undefined;
  output: Uint8Array;
  fulfilled: boolean;
}

export interface PendingUnwrapsResponse {
  payments: Payment[];
}

function createBaseuint128(): uint128 {
  return { lo: 0n, hi: 0n };
}

export const uint128: MessageFns<uint128> = {
  encode(message: uint128, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lo !== 0n) {
      if (BigInt.asUintN(64, message.lo) !== message.lo) {
        throw new globalThis.Error("value provided for field message.lo of type uint64 too large");
      }
      writer.uint32(8).uint64(message.lo);
    }
    if (message.hi !== 0n) {
      if (BigInt.asUintN(64, message.hi) !== message.hi) {
        throw new globalThis.Error("value provided for field message.hi of type uint64 too large");
      }
      writer.uint32(16).uint64(message.hi);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): uint128 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseuint128();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.lo = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.hi = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): uint128 {
    return { lo: isSet(object.lo) ? BigInt(object.lo) : 0n, hi: isSet(object.hi) ? BigInt(object.hi) : 0n };
  },

  toJSON(message: uint128): unknown {
    const obj: any = {};
    if (message.lo !== 0n) {
      obj.lo = message.lo.toString();
    }
    if (message.hi !== 0n) {
      obj.hi = message.hi.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<uint128>, I>>(base?: I): uint128 {
    return uint128.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<uint128>, I>>(object: I): uint128 {
    const message = createBaseuint128();
    message.lo = object.lo ?? 0n;
    message.hi = object.hi ?? 0n;
    return message;
  },
};

function createBaseAlkaneId(): AlkaneId {
  return { block: undefined, tx: undefined };
}

export const AlkaneId: MessageFns<AlkaneId> = {
  encode(message: AlkaneId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.block !== undefined) {
      uint128.encode(message.block, writer.uint32(10).fork()).join();
    }
    if (message.tx !== undefined) {
      uint128.encode(message.tx, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlkaneId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlkaneId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.block = uint128.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tx = uint128.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlkaneId {
    return {
      block: isSet(object.block) ? uint128.fromJSON(object.block) : undefined,
      tx: isSet(object.tx) ? uint128.fromJSON(object.tx) : undefined,
    };
  },

  toJSON(message: AlkaneId): unknown {
    const obj: any = {};
    if (message.block !== undefined) {
      obj.block = uint128.toJSON(message.block);
    }
    if (message.tx !== undefined) {
      obj.tx = uint128.toJSON(message.tx);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AlkaneId>, I>>(base?: I): AlkaneId {
    return AlkaneId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlkaneId>, I>>(object: I): AlkaneId {
    const message = createBaseAlkaneId();
    message.block = (object.block !== undefined && object.block !== null)
      ? uint128.fromPartial(object.block)
      : undefined;
    message.tx = (object.tx !== undefined && object.tx !== null) ? uint128.fromPartial(object.tx) : undefined;
    return message;
  },
};

function createBaseAlkaneTransfer(): AlkaneTransfer {
  return { id: undefined, value: undefined };
}

export const AlkaneTransfer: MessageFns<AlkaneTransfer> = {
  encode(message: AlkaneTransfer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      AlkaneId.encode(message.id, writer.uint32(10).fork()).join();
    }
    if (message.value !== undefined) {
      uint128.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlkaneTransfer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlkaneTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = AlkaneId.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = uint128.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlkaneTransfer {
    return {
      id: isSet(object.id) ? AlkaneId.fromJSON(object.id) : undefined,
      value: isSet(object.value) ? uint128.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: AlkaneTransfer): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = AlkaneId.toJSON(message.id);
    }
    if (message.value !== undefined) {
      obj.value = uint128.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AlkaneTransfer>, I>>(base?: I): AlkaneTransfer {
    return AlkaneTransfer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlkaneTransfer>, I>>(object: I): AlkaneTransfer {
    const message = createBaseAlkaneTransfer();
    message.id = (object.id !== undefined && object.id !== null) ? AlkaneId.fromPartial(object.id) : undefined;
    message.value = (object.value !== undefined && object.value !== null)
      ? uint128.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseMultiSimulateRequest(): MultiSimulateRequest {
  return { parcels: [] };
}

export const MultiSimulateRequest: MessageFns<MultiSimulateRequest> = {
  encode(message: MultiSimulateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.parcels) {
      MessageContextParcel.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiSimulateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiSimulateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parcels.push(MessageContextParcel.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiSimulateRequest {
    return {
      parcels: globalThis.Array.isArray(object?.parcels)
        ? object.parcels.map((e: any) => MessageContextParcel.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiSimulateRequest): unknown {
    const obj: any = {};
    if (message.parcels?.length) {
      obj.parcels = message.parcels.map((e) => MessageContextParcel.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiSimulateRequest>, I>>(base?: I): MultiSimulateRequest {
    return MultiSimulateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiSimulateRequest>, I>>(object: I): MultiSimulateRequest {
    const message = createBaseMultiSimulateRequest();
    message.parcels = object.parcels?.map((e) => MessageContextParcel.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMessageContextParcel(): MessageContextParcel {
  return {
    alkanes: [],
    transaction: new Uint8Array(0),
    block: new Uint8Array(0),
    height: 0n,
    txindex: 0,
    calldata: new Uint8Array(0),
    vout: 0,
    pointer: 0,
    refundPointer: 0,
  };
}

export const MessageContextParcel: MessageFns<MessageContextParcel> = {
  encode(message: MessageContextParcel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.alkanes) {
      AlkaneTransfer.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.transaction.length !== 0) {
      writer.uint32(18).bytes(message.transaction);
    }
    if (message.block.length !== 0) {
      writer.uint32(26).bytes(message.block);
    }
    if (message.height !== 0n) {
      if (BigInt.asUintN(64, message.height) !== message.height) {
        throw new globalThis.Error("value provided for field message.height of type uint64 too large");
      }
      writer.uint32(32).uint64(message.height);
    }
    if (message.txindex !== 0) {
      writer.uint32(48).uint32(message.txindex);
    }
    if (message.calldata.length !== 0) {
      writer.uint32(42).bytes(message.calldata);
    }
    if (message.vout !== 0) {
      writer.uint32(56).uint32(message.vout);
    }
    if (message.pointer !== 0) {
      writer.uint32(64).uint32(message.pointer);
    }
    if (message.refundPointer !== 0) {
      writer.uint32(72).uint32(message.refundPointer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageContextParcel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageContextParcel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.alkanes.push(AlkaneTransfer.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.transaction = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.block = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.height = reader.uint64() as bigint;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.txindex = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.calldata = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.vout = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.pointer = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.refundPointer = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageContextParcel {
    return {
      alkanes: globalThis.Array.isArray(object?.alkanes)
        ? object.alkanes.map((e: any) => AlkaneTransfer.fromJSON(e))
        : [],
      transaction: isSet(object.transaction) ? bytesFromBase64(object.transaction) : new Uint8Array(0),
      block: isSet(object.block) ? bytesFromBase64(object.block) : new Uint8Array(0),
      height: isSet(object.height) ? BigInt(object.height) : 0n,
      txindex: isSet(object.txindex) ? globalThis.Number(object.txindex) : 0,
      calldata: isSet(object.calldata) ? bytesFromBase64(object.calldata) : new Uint8Array(0),
      vout: isSet(object.vout) ? globalThis.Number(object.vout) : 0,
      pointer: isSet(object.pointer) ? globalThis.Number(object.pointer) : 0,
      refundPointer: isSet(object.refundPointer) ? globalThis.Number(object.refundPointer) : 0,
    };
  },

  toJSON(message: MessageContextParcel): unknown {
    const obj: any = {};
    if (message.alkanes?.length) {
      obj.alkanes = message.alkanes.map((e) => AlkaneTransfer.toJSON(e));
    }
    if (message.transaction.length !== 0) {
      obj.transaction = base64FromBytes(message.transaction);
    }
    if (message.block.length !== 0) {
      obj.block = base64FromBytes(message.block);
    }
    if (message.height !== 0n) {
      obj.height = message.height.toString();
    }
    if (message.txindex !== 0) {
      obj.txindex = Math.round(message.txindex);
    }
    if (message.calldata.length !== 0) {
      obj.calldata = base64FromBytes(message.calldata);
    }
    if (message.vout !== 0) {
      obj.vout = Math.round(message.vout);
    }
    if (message.pointer !== 0) {
      obj.pointer = Math.round(message.pointer);
    }
    if (message.refundPointer !== 0) {
      obj.refundPointer = Math.round(message.refundPointer);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageContextParcel>, I>>(base?: I): MessageContextParcel {
    return MessageContextParcel.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageContextParcel>, I>>(object: I): MessageContextParcel {
    const message = createBaseMessageContextParcel();
    message.alkanes = object.alkanes?.map((e) => AlkaneTransfer.fromPartial(e)) || [];
    message.transaction = object.transaction ?? new Uint8Array(0);
    message.block = object.block ?? new Uint8Array(0);
    message.height = object.height ?? 0n;
    message.txindex = object.txindex ?? 0;
    message.calldata = object.calldata ?? new Uint8Array(0);
    message.vout = object.vout ?? 0;
    message.pointer = object.pointer ?? 0;
    message.refundPointer = object.refundPointer ?? 0;
    return message;
  },
};

function createBaseKeyValuePair(): KeyValuePair {
  return { key: new Uint8Array(0), value: new Uint8Array(0) };
}

export const KeyValuePair: MessageFns<KeyValuePair> = {
  encode(message: KeyValuePair, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key.length !== 0) {
      writer.uint32(10).bytes(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyValuePair {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyValuePair();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyValuePair {
    return {
      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(0),
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
    };
  },

  toJSON(message: KeyValuePair): unknown {
    const obj: any = {};
    if (message.key.length !== 0) {
      obj.key = base64FromBytes(message.key);
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KeyValuePair>, I>>(base?: I): KeyValuePair {
    return KeyValuePair.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KeyValuePair>, I>>(object: I): KeyValuePair {
    const message = createBaseKeyValuePair();
    message.key = object.key ?? new Uint8Array(0);
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseExtendedCallResponse(): ExtendedCallResponse {
  return { alkanes: [], storage: [], data: new Uint8Array(0) };
}

export const ExtendedCallResponse: MessageFns<ExtendedCallResponse> = {
  encode(message: ExtendedCallResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.alkanes) {
      AlkaneTransfer.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.storage) {
      KeyValuePair.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.data.length !== 0) {
      writer.uint32(26).bytes(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExtendedCallResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExtendedCallResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.alkanes.push(AlkaneTransfer.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.storage.push(KeyValuePair.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExtendedCallResponse {
    return {
      alkanes: globalThis.Array.isArray(object?.alkanes)
        ? object.alkanes.map((e: any) => AlkaneTransfer.fromJSON(e))
        : [],
      storage: globalThis.Array.isArray(object?.storage)
        ? object.storage.map((e: any) => KeyValuePair.fromJSON(e))
        : [],
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
    };
  },

  toJSON(message: ExtendedCallResponse): unknown {
    const obj: any = {};
    if (message.alkanes?.length) {
      obj.alkanes = message.alkanes.map((e) => AlkaneTransfer.toJSON(e));
    }
    if (message.storage?.length) {
      obj.storage = message.storage.map((e) => KeyValuePair.toJSON(e));
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExtendedCallResponse>, I>>(base?: I): ExtendedCallResponse {
    return ExtendedCallResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExtendedCallResponse>, I>>(object: I): ExtendedCallResponse {
    const message = createBaseExtendedCallResponse();
    message.alkanes = object.alkanes?.map((e) => AlkaneTransfer.fromPartial(e)) || [];
    message.storage = object.storage?.map((e) => KeyValuePair.fromPartial(e)) || [];
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBaseContext(): Context {
  return { myself: undefined, caller: undefined, inputs: [], vout: 0, incomingAlkanes: [] };
}

export const Context: MessageFns<Context> = {
  encode(message: Context, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.myself !== undefined) {
      AlkaneId.encode(message.myself, writer.uint32(10).fork()).join();
    }
    if (message.caller !== undefined) {
      AlkaneId.encode(message.caller, writer.uint32(18).fork()).join();
    }
    for (const v of message.inputs) {
      uint128.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.vout !== 0) {
      writer.uint32(32).uint32(message.vout);
    }
    for (const v of message.incomingAlkanes) {
      AlkaneTransfer.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Context {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.myself = AlkaneId.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.caller = AlkaneId.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.inputs.push(uint128.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.vout = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.incomingAlkanes.push(AlkaneTransfer.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Context {
    return {
      myself: isSet(object.myself) ? AlkaneId.fromJSON(object.myself) : undefined,
      caller: isSet(object.caller) ? AlkaneId.fromJSON(object.caller) : undefined,
      inputs: globalThis.Array.isArray(object?.inputs) ? object.inputs.map((e: any) => uint128.fromJSON(e)) : [],
      vout: isSet(object.vout) ? globalThis.Number(object.vout) : 0,
      incomingAlkanes: globalThis.Array.isArray(object?.incomingAlkanes)
        ? object.incomingAlkanes.map((e: any) => AlkaneTransfer.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Context): unknown {
    const obj: any = {};
    if (message.myself !== undefined) {
      obj.myself = AlkaneId.toJSON(message.myself);
    }
    if (message.caller !== undefined) {
      obj.caller = AlkaneId.toJSON(message.caller);
    }
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => uint128.toJSON(e));
    }
    if (message.vout !== 0) {
      obj.vout = Math.round(message.vout);
    }
    if (message.incomingAlkanes?.length) {
      obj.incomingAlkanes = message.incomingAlkanes.map((e) => AlkaneTransfer.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Context>, I>>(base?: I): Context {
    return Context.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Context>, I>>(object: I): Context {
    const message = createBaseContext();
    message.myself = (object.myself !== undefined && object.myself !== null)
      ? AlkaneId.fromPartial(object.myself)
      : undefined;
    message.caller = (object.caller !== undefined && object.caller !== null)
      ? AlkaneId.fromPartial(object.caller)
      : undefined;
    message.inputs = object.inputs?.map((e) => uint128.fromPartial(e)) || [];
    message.vout = object.vout ?? 0;
    message.incomingAlkanes = object.incomingAlkanes?.map((e) => AlkaneTransfer.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTraceContext(): TraceContext {
  return { inner: undefined, fuel: 0n };
}

export const TraceContext: MessageFns<TraceContext> = {
  encode(message: TraceContext, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inner !== undefined) {
      Context.encode(message.inner, writer.uint32(10).fork()).join();
    }
    if (message.fuel !== 0n) {
      if (BigInt.asUintN(64, message.fuel) !== message.fuel) {
        throw new globalThis.Error("value provided for field message.fuel of type uint64 too large");
      }
      writer.uint32(16).uint64(message.fuel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TraceContext {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTraceContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.inner = Context.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.fuel = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TraceContext {
    return {
      inner: isSet(object.inner) ? Context.fromJSON(object.inner) : undefined,
      fuel: isSet(object.fuel) ? BigInt(object.fuel) : 0n,
    };
  },

  toJSON(message: TraceContext): unknown {
    const obj: any = {};
    if (message.inner !== undefined) {
      obj.inner = Context.toJSON(message.inner);
    }
    if (message.fuel !== 0n) {
      obj.fuel = message.fuel.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TraceContext>, I>>(base?: I): TraceContext {
    return TraceContext.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TraceContext>, I>>(object: I): TraceContext {
    const message = createBaseTraceContext();
    message.inner = (object.inner !== undefined && object.inner !== null)
      ? Context.fromPartial(object.inner)
      : undefined;
    message.fuel = object.fuel ?? 0n;
    return message;
  },
};

function createBaseAlkanesEnterContext(): AlkanesEnterContext {
  return { callType: 0, context: undefined };
}

export const AlkanesEnterContext: MessageFns<AlkanesEnterContext> = {
  encode(message: AlkanesEnterContext, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.callType !== 0) {
      writer.uint32(8).int32(message.callType);
    }
    if (message.context !== undefined) {
      TraceContext.encode(message.context, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlkanesEnterContext {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlkanesEnterContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.callType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.context = TraceContext.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlkanesEnterContext {
    return {
      callType: isSet(object.callType) ? alkanesTraceCallTypeFromJSON(object.callType) : 0,
      context: isSet(object.context) ? TraceContext.fromJSON(object.context) : undefined,
    };
  },

  toJSON(message: AlkanesEnterContext): unknown {
    const obj: any = {};
    if (message.callType !== 0) {
      obj.callType = alkanesTraceCallTypeToJSON(message.callType);
    }
    if (message.context !== undefined) {
      obj.context = TraceContext.toJSON(message.context);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AlkanesEnterContext>, I>>(base?: I): AlkanesEnterContext {
    return AlkanesEnterContext.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlkanesEnterContext>, I>>(object: I): AlkanesEnterContext {
    const message = createBaseAlkanesEnterContext();
    message.callType = object.callType ?? 0;
    message.context = (object.context !== undefined && object.context !== null)
      ? TraceContext.fromPartial(object.context)
      : undefined;
    return message;
  },
};

function createBaseAlkanesExitContext(): AlkanesExitContext {
  return { status: 0, response: undefined };
}

export const AlkanesExitContext: MessageFns<AlkanesExitContext> = {
  encode(message: AlkanesExitContext, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.response !== undefined) {
      ExtendedCallResponse.encode(message.response, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlkanesExitContext {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlkanesExitContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.response = ExtendedCallResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlkanesExitContext {
    return {
      status: isSet(object.status) ? alkanesTraceStatusFlagFromJSON(object.status) : 0,
      response: isSet(object.response) ? ExtendedCallResponse.fromJSON(object.response) : undefined,
    };
  },

  toJSON(message: AlkanesExitContext): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = alkanesTraceStatusFlagToJSON(message.status);
    }
    if (message.response !== undefined) {
      obj.response = ExtendedCallResponse.toJSON(message.response);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AlkanesExitContext>, I>>(base?: I): AlkanesExitContext {
    return AlkanesExitContext.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlkanesExitContext>, I>>(object: I): AlkanesExitContext {
    const message = createBaseAlkanesExitContext();
    message.status = object.status ?? 0;
    message.response = (object.response !== undefined && object.response !== null)
      ? ExtendedCallResponse.fromPartial(object.response)
      : undefined;
    return message;
  },
};

function createBaseAlkanesCreate(): AlkanesCreate {
  return { newAlkane: undefined };
}

export const AlkanesCreate: MessageFns<AlkanesCreate> = {
  encode(message: AlkanesCreate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.newAlkane !== undefined) {
      AlkaneId.encode(message.newAlkane, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlkanesCreate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlkanesCreate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.newAlkane = AlkaneId.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlkanesCreate {
    return { newAlkane: isSet(object.newAlkane) ? AlkaneId.fromJSON(object.newAlkane) : undefined };
  },

  toJSON(message: AlkanesCreate): unknown {
    const obj: any = {};
    if (message.newAlkane !== undefined) {
      obj.newAlkane = AlkaneId.toJSON(message.newAlkane);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AlkanesCreate>, I>>(base?: I): AlkanesCreate {
    return AlkanesCreate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlkanesCreate>, I>>(object: I): AlkanesCreate {
    const message = createBaseAlkanesCreate();
    message.newAlkane = (object.newAlkane !== undefined && object.newAlkane !== null)
      ? AlkaneId.fromPartial(object.newAlkane)
      : undefined;
    return message;
  },
};

function createBaseAlkanesTraceEvent(): AlkanesTraceEvent {
  return { enterContext: undefined, exitContext: undefined, createAlkane: undefined };
}

export const AlkanesTraceEvent: MessageFns<AlkanesTraceEvent> = {
  encode(message: AlkanesTraceEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enterContext !== undefined) {
      AlkanesEnterContext.encode(message.enterContext, writer.uint32(10).fork()).join();
    }
    if (message.exitContext !== undefined) {
      AlkanesExitContext.encode(message.exitContext, writer.uint32(18).fork()).join();
    }
    if (message.createAlkane !== undefined) {
      AlkanesCreate.encode(message.createAlkane, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlkanesTraceEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlkanesTraceEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.enterContext = AlkanesEnterContext.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.exitContext = AlkanesExitContext.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createAlkane = AlkanesCreate.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlkanesTraceEvent {
    return {
      enterContext: isSet(object.enterContext) ? AlkanesEnterContext.fromJSON(object.enterContext) : undefined,
      exitContext: isSet(object.exitContext) ? AlkanesExitContext.fromJSON(object.exitContext) : undefined,
      createAlkane: isSet(object.createAlkane) ? AlkanesCreate.fromJSON(object.createAlkane) : undefined,
    };
  },

  toJSON(message: AlkanesTraceEvent): unknown {
    const obj: any = {};
    if (message.enterContext !== undefined) {
      obj.enterContext = AlkanesEnterContext.toJSON(message.enterContext);
    }
    if (message.exitContext !== undefined) {
      obj.exitContext = AlkanesExitContext.toJSON(message.exitContext);
    }
    if (message.createAlkane !== undefined) {
      obj.createAlkane = AlkanesCreate.toJSON(message.createAlkane);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AlkanesTraceEvent>, I>>(base?: I): AlkanesTraceEvent {
    return AlkanesTraceEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlkanesTraceEvent>, I>>(object: I): AlkanesTraceEvent {
    const message = createBaseAlkanesTraceEvent();
    message.enterContext = (object.enterContext !== undefined && object.enterContext !== null)
      ? AlkanesEnterContext.fromPartial(object.enterContext)
      : undefined;
    message.exitContext = (object.exitContext !== undefined && object.exitContext !== null)
      ? AlkanesExitContext.fromPartial(object.exitContext)
      : undefined;
    message.createAlkane = (object.createAlkane !== undefined && object.createAlkane !== null)
      ? AlkanesCreate.fromPartial(object.createAlkane)
      : undefined;
    return message;
  },
};

function createBaseAlkanesBlockEvent(): AlkanesBlockEvent {
  return { traces: undefined, outpoint: undefined, txindex: 0n };
}

export const AlkanesBlockEvent: MessageFns<AlkanesBlockEvent> = {
  encode(message: AlkanesBlockEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.traces !== undefined) {
      AlkanesTrace.encode(message.traces, writer.uint32(10).fork()).join();
    }
    if (message.outpoint !== undefined) {
      Outpoint.encode(message.outpoint, writer.uint32(18).fork()).join();
    }
    if (message.txindex !== 0n) {
      if (BigInt.asUintN(64, message.txindex) !== message.txindex) {
        throw new globalThis.Error("value provided for field message.txindex of type uint64 too large");
      }
      writer.uint32(24).uint64(message.txindex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlkanesBlockEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlkanesBlockEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.traces = AlkanesTrace.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.outpoint = Outpoint.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.txindex = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlkanesBlockEvent {
    return {
      traces: isSet(object.traces) ? AlkanesTrace.fromJSON(object.traces) : undefined,
      outpoint: isSet(object.outpoint) ? Outpoint.fromJSON(object.outpoint) : undefined,
      txindex: isSet(object.txindex) ? BigInt(object.txindex) : 0n,
    };
  },

  toJSON(message: AlkanesBlockEvent): unknown {
    const obj: any = {};
    if (message.traces !== undefined) {
      obj.traces = AlkanesTrace.toJSON(message.traces);
    }
    if (message.outpoint !== undefined) {
      obj.outpoint = Outpoint.toJSON(message.outpoint);
    }
    if (message.txindex !== 0n) {
      obj.txindex = message.txindex.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AlkanesBlockEvent>, I>>(base?: I): AlkanesBlockEvent {
    return AlkanesBlockEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlkanesBlockEvent>, I>>(object: I): AlkanesBlockEvent {
    const message = createBaseAlkanesBlockEvent();
    message.traces = (object.traces !== undefined && object.traces !== null)
      ? AlkanesTrace.fromPartial(object.traces)
      : undefined;
    message.outpoint = (object.outpoint !== undefined && object.outpoint !== null)
      ? Outpoint.fromPartial(object.outpoint)
      : undefined;
    message.txindex = object.txindex ?? 0n;
    return message;
  },
};

function createBaseAlkanesBlockTraceEvent(): AlkanesBlockTraceEvent {
  return { events: [] };
}

export const AlkanesBlockTraceEvent: MessageFns<AlkanesBlockTraceEvent> = {
  encode(message: AlkanesBlockTraceEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.events) {
      AlkanesBlockEvent.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlkanesBlockTraceEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlkanesBlockTraceEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.events.push(AlkanesBlockEvent.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlkanesBlockTraceEvent {
    return {
      events: globalThis.Array.isArray(object?.events)
        ? object.events.map((e: any) => AlkanesBlockEvent.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AlkanesBlockTraceEvent): unknown {
    const obj: any = {};
    if (message.events?.length) {
      obj.events = message.events.map((e) => AlkanesBlockEvent.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AlkanesBlockTraceEvent>, I>>(base?: I): AlkanesBlockTraceEvent {
    return AlkanesBlockTraceEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlkanesBlockTraceEvent>, I>>(object: I): AlkanesBlockTraceEvent {
    const message = createBaseAlkanesBlockTraceEvent();
    message.events = object.events?.map((e) => AlkanesBlockEvent.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAlkanesTrace(): AlkanesTrace {
  return { events: [] };
}

export const AlkanesTrace: MessageFns<AlkanesTrace> = {
  encode(message: AlkanesTrace, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.events) {
      AlkanesTraceEvent.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlkanesTrace {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlkanesTrace();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.events.push(AlkanesTraceEvent.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlkanesTrace {
    return {
      events: globalThis.Array.isArray(object?.events)
        ? object.events.map((e: any) => AlkanesTraceEvent.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AlkanesTrace): unknown {
    const obj: any = {};
    if (message.events?.length) {
      obj.events = message.events.map((e) => AlkanesTraceEvent.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AlkanesTrace>, I>>(base?: I): AlkanesTrace {
    return AlkanesTrace.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlkanesTrace>, I>>(object: I): AlkanesTrace {
    const message = createBaseAlkanesTrace();
    message.events = object.events?.map((e) => AlkanesTraceEvent.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSimulateResponse(): SimulateResponse {
  return { execution: undefined, gasUsed: 0n, error: "" };
}

export const SimulateResponse: MessageFns<SimulateResponse> = {
  encode(message: SimulateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.execution !== undefined) {
      ExtendedCallResponse.encode(message.execution, writer.uint32(10).fork()).join();
    }
    if (message.gasUsed !== 0n) {
      if (BigInt.asUintN(64, message.gasUsed) !== message.gasUsed) {
        throw new globalThis.Error("value provided for field message.gasUsed of type uint64 too large");
      }
      writer.uint32(16).uint64(message.gasUsed);
    }
    if (message.error !== "") {
      writer.uint32(26).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimulateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimulateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.execution = ExtendedCallResponse.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.gasUsed = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimulateResponse {
    return {
      execution: isSet(object.execution) ? ExtendedCallResponse.fromJSON(object.execution) : undefined,
      gasUsed: isSet(object.gasUsed) ? BigInt(object.gasUsed) : 0n,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: SimulateResponse): unknown {
    const obj: any = {};
    if (message.execution !== undefined) {
      obj.execution = ExtendedCallResponse.toJSON(message.execution);
    }
    if (message.gasUsed !== 0n) {
      obj.gasUsed = message.gasUsed.toString();
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimulateResponse>, I>>(base?: I): SimulateResponse {
    return SimulateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimulateResponse>, I>>(object: I): SimulateResponse {
    const message = createBaseSimulateResponse();
    message.execution = (object.execution !== undefined && object.execution !== null)
      ? ExtendedCallResponse.fromPartial(object.execution)
      : undefined;
    message.gasUsed = object.gasUsed ?? 0n;
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseMultiSimulateResponse(): MultiSimulateResponse {
  return { responses: [], error: "" };
}

export const MultiSimulateResponse: MessageFns<MultiSimulateResponse> = {
  encode(message: MultiSimulateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.responses) {
      SimulateResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiSimulateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiSimulateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.responses.push(SimulateResponse.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiSimulateResponse {
    return {
      responses: globalThis.Array.isArray(object?.responses)
        ? object.responses.map((e: any) => SimulateResponse.fromJSON(e))
        : [],
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: MultiSimulateResponse): unknown {
    const obj: any = {};
    if (message.responses?.length) {
      obj.responses = message.responses.map((e) => SimulateResponse.toJSON(e));
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiSimulateResponse>, I>>(base?: I): MultiSimulateResponse {
    return MultiSimulateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiSimulateResponse>, I>>(object: I): MultiSimulateResponse {
    const message = createBaseMultiSimulateResponse();
    message.responses = object.responses?.map((e) => SimulateResponse.fromPartial(e)) || [];
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseAlkaneInventoryRequest(): AlkaneInventoryRequest {
  return { id: undefined };
}

export const AlkaneInventoryRequest: MessageFns<AlkaneInventoryRequest> = {
  encode(message: AlkaneInventoryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      AlkaneId.encode(message.id, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlkaneInventoryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlkaneInventoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = AlkaneId.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlkaneInventoryRequest {
    return { id: isSet(object.id) ? AlkaneId.fromJSON(object.id) : undefined };
  },

  toJSON(message: AlkaneInventoryRequest): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = AlkaneId.toJSON(message.id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AlkaneInventoryRequest>, I>>(base?: I): AlkaneInventoryRequest {
    return AlkaneInventoryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlkaneInventoryRequest>, I>>(object: I): AlkaneInventoryRequest {
    const message = createBaseAlkaneInventoryRequest();
    message.id = (object.id !== undefined && object.id !== null) ? AlkaneId.fromPartial(object.id) : undefined;
    return message;
  },
};

function createBaseAlkaneIdToOutpointRequest(): AlkaneIdToOutpointRequest {
  return { id: undefined };
}

export const AlkaneIdToOutpointRequest: MessageFns<AlkaneIdToOutpointRequest> = {
  encode(message: AlkaneIdToOutpointRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      AlkaneId.encode(message.id, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlkaneIdToOutpointRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlkaneIdToOutpointRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = AlkaneId.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlkaneIdToOutpointRequest {
    return { id: isSet(object.id) ? AlkaneId.fromJSON(object.id) : undefined };
  },

  toJSON(message: AlkaneIdToOutpointRequest): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = AlkaneId.toJSON(message.id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AlkaneIdToOutpointRequest>, I>>(base?: I): AlkaneIdToOutpointRequest {
    return AlkaneIdToOutpointRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlkaneIdToOutpointRequest>, I>>(object: I): AlkaneIdToOutpointRequest {
    const message = createBaseAlkaneIdToOutpointRequest();
    message.id = (object.id !== undefined && object.id !== null) ? AlkaneId.fromPartial(object.id) : undefined;
    return message;
  },
};

function createBaseAlkaneInventoryResponse(): AlkaneInventoryResponse {
  return { alkanes: [] };
}

export const AlkaneInventoryResponse: MessageFns<AlkaneInventoryResponse> = {
  encode(message: AlkaneInventoryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.alkanes) {
      AlkaneTransfer.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlkaneInventoryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlkaneInventoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.alkanes.push(AlkaneTransfer.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlkaneInventoryResponse {
    return {
      alkanes: globalThis.Array.isArray(object?.alkanes)
        ? object.alkanes.map((e: any) => AlkaneTransfer.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AlkaneInventoryResponse): unknown {
    const obj: any = {};
    if (message.alkanes?.length) {
      obj.alkanes = message.alkanes.map((e) => AlkaneTransfer.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AlkaneInventoryResponse>, I>>(base?: I): AlkaneInventoryResponse {
    return AlkaneInventoryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlkaneInventoryResponse>, I>>(object: I): AlkaneInventoryResponse {
    const message = createBaseAlkaneInventoryResponse();
    message.alkanes = object.alkanes?.map((e) => AlkaneTransfer.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAlkaneStorageRequest(): AlkaneStorageRequest {
  return { id: undefined, path: new Uint8Array(0) };
}

export const AlkaneStorageRequest: MessageFns<AlkaneStorageRequest> = {
  encode(message: AlkaneStorageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      AlkaneId.encode(message.id, writer.uint32(10).fork()).join();
    }
    if (message.path.length !== 0) {
      writer.uint32(18).bytes(message.path);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlkaneStorageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlkaneStorageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = AlkaneId.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.path = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlkaneStorageRequest {
    return {
      id: isSet(object.id) ? AlkaneId.fromJSON(object.id) : undefined,
      path: isSet(object.path) ? bytesFromBase64(object.path) : new Uint8Array(0),
    };
  },

  toJSON(message: AlkaneStorageRequest): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = AlkaneId.toJSON(message.id);
    }
    if (message.path.length !== 0) {
      obj.path = base64FromBytes(message.path);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AlkaneStorageRequest>, I>>(base?: I): AlkaneStorageRequest {
    return AlkaneStorageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlkaneStorageRequest>, I>>(object: I): AlkaneStorageRequest {
    const message = createBaseAlkaneStorageRequest();
    message.id = (object.id !== undefined && object.id !== null) ? AlkaneId.fromPartial(object.id) : undefined;
    message.path = object.path ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAlkaneStorageResponse(): AlkaneStorageResponse {
  return { value: new Uint8Array(0) };
}

export const AlkaneStorageResponse: MessageFns<AlkaneStorageResponse> = {
  encode(message: AlkaneStorageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value.length !== 0) {
      writer.uint32(10).bytes(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlkaneStorageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlkaneStorageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlkaneStorageResponse {
    return { value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0) };
  },

  toJSON(message: AlkaneStorageResponse): unknown {
    const obj: any = {};
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AlkaneStorageResponse>, I>>(base?: I): AlkaneStorageResponse {
    return AlkaneStorageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlkaneStorageResponse>, I>>(object: I): AlkaneStorageResponse {
    const message = createBaseAlkaneStorageResponse();
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAlkaneIdToOutpointResponse(): AlkaneIdToOutpointResponse {
  return { txid: new Uint8Array(0), vout: 0 };
}

export const AlkaneIdToOutpointResponse: MessageFns<AlkaneIdToOutpointResponse> = {
  encode(message: AlkaneIdToOutpointResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.txid.length !== 0) {
      writer.uint32(10).bytes(message.txid);
    }
    if (message.vout !== 0) {
      writer.uint32(16).uint32(message.vout);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlkaneIdToOutpointResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlkaneIdToOutpointResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.txid = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.vout = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlkaneIdToOutpointResponse {
    return {
      txid: isSet(object.txid) ? bytesFromBase64(object.txid) : new Uint8Array(0),
      vout: isSet(object.vout) ? globalThis.Number(object.vout) : 0,
    };
  },

  toJSON(message: AlkaneIdToOutpointResponse): unknown {
    const obj: any = {};
    if (message.txid.length !== 0) {
      obj.txid = base64FromBytes(message.txid);
    }
    if (message.vout !== 0) {
      obj.vout = Math.round(message.vout);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AlkaneIdToOutpointResponse>, I>>(base?: I): AlkaneIdToOutpointResponse {
    return AlkaneIdToOutpointResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlkaneIdToOutpointResponse>, I>>(object: I): AlkaneIdToOutpointResponse {
    const message = createBaseAlkaneIdToOutpointResponse();
    message.txid = object.txid ?? new Uint8Array(0);
    message.vout = object.vout ?? 0;
    return message;
  },
};

function createBaseOutpoint(): Outpoint {
  return { txid: new Uint8Array(0), vout: 0 };
}

export const Outpoint: MessageFns<Outpoint> = {
  encode(message: Outpoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.txid.length !== 0) {
      writer.uint32(10).bytes(message.txid);
    }
    if (message.vout !== 0) {
      writer.uint32(16).uint32(message.vout);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Outpoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutpoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.txid = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.vout = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Outpoint {
    return {
      txid: isSet(object.txid) ? bytesFromBase64(object.txid) : new Uint8Array(0),
      vout: isSet(object.vout) ? globalThis.Number(object.vout) : 0,
    };
  },

  toJSON(message: Outpoint): unknown {
    const obj: any = {};
    if (message.txid.length !== 0) {
      obj.txid = base64FromBytes(message.txid);
    }
    if (message.vout !== 0) {
      obj.vout = Math.round(message.vout);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Outpoint>, I>>(base?: I): Outpoint {
    return Outpoint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Outpoint>, I>>(object: I): Outpoint {
    const message = createBaseOutpoint();
    message.txid = object.txid ?? new Uint8Array(0);
    message.vout = object.vout ?? 0;
    return message;
  },
};

function createBaseTrace(): Trace {
  return { outpoint: undefined, trace: undefined };
}

export const Trace: MessageFns<Trace> = {
  encode(message: Trace, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.outpoint !== undefined) {
      Outpoint.encode(message.outpoint, writer.uint32(10).fork()).join();
    }
    if (message.trace !== undefined) {
      AlkanesTrace.encode(message.trace, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Trace {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrace();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.outpoint = Outpoint.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.trace = AlkanesTrace.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Trace {
    return {
      outpoint: isSet(object.outpoint) ? Outpoint.fromJSON(object.outpoint) : undefined,
      trace: isSet(object.trace) ? AlkanesTrace.fromJSON(object.trace) : undefined,
    };
  },

  toJSON(message: Trace): unknown {
    const obj: any = {};
    if (message.outpoint !== undefined) {
      obj.outpoint = Outpoint.toJSON(message.outpoint);
    }
    if (message.trace !== undefined) {
      obj.trace = AlkanesTrace.toJSON(message.trace);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Trace>, I>>(base?: I): Trace {
    return Trace.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Trace>, I>>(object: I): Trace {
    const message = createBaseTrace();
    message.outpoint = (object.outpoint !== undefined && object.outpoint !== null)
      ? Outpoint.fromPartial(object.outpoint)
      : undefined;
    message.trace = (object.trace !== undefined && object.trace !== null)
      ? AlkanesTrace.fromPartial(object.trace)
      : undefined;
    return message;
  },
};

function createBaseTraceBlockRequest(): TraceBlockRequest {
  return { block: 0n };
}

export const TraceBlockRequest: MessageFns<TraceBlockRequest> = {
  encode(message: TraceBlockRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.block !== 0n) {
      if (BigInt.asUintN(64, message.block) !== message.block) {
        throw new globalThis.Error("value provided for field message.block of type uint64 too large");
      }
      writer.uint32(8).uint64(message.block);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TraceBlockRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTraceBlockRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.block = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TraceBlockRequest {
    return { block: isSet(object.block) ? BigInt(object.block) : 0n };
  },

  toJSON(message: TraceBlockRequest): unknown {
    const obj: any = {};
    if (message.block !== 0n) {
      obj.block = message.block.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TraceBlockRequest>, I>>(base?: I): TraceBlockRequest {
    return TraceBlockRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TraceBlockRequest>, I>>(object: I): TraceBlockRequest {
    const message = createBaseTraceBlockRequest();
    message.block = object.block ?? 0n;
    return message;
  },
};

function createBaseTraceBlockResponse(): TraceBlockResponse {
  return { traces: [] };
}

export const TraceBlockResponse: MessageFns<TraceBlockResponse> = {
  encode(message: TraceBlockResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.traces) {
      Trace.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TraceBlockResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTraceBlockResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.traces.push(Trace.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TraceBlockResponse {
    return { traces: globalThis.Array.isArray(object?.traces) ? object.traces.map((e: any) => Trace.fromJSON(e)) : [] };
  },

  toJSON(message: TraceBlockResponse): unknown {
    const obj: any = {};
    if (message.traces?.length) {
      obj.traces = message.traces.map((e) => Trace.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TraceBlockResponse>, I>>(base?: I): TraceBlockResponse {
    return TraceBlockResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TraceBlockResponse>, I>>(object: I): TraceBlockResponse {
    const message = createBaseTraceBlockResponse();
    message.traces = object.traces?.map((e) => Trace.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBytecodeRequest(): BytecodeRequest {
  return { id: undefined };
}

export const BytecodeRequest: MessageFns<BytecodeRequest> = {
  encode(message: BytecodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      AlkaneId.encode(message.id, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BytecodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBytecodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = AlkaneId.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BytecodeRequest {
    return { id: isSet(object.id) ? AlkaneId.fromJSON(object.id) : undefined };
  },

  toJSON(message: BytecodeRequest): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = AlkaneId.toJSON(message.id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BytecodeRequest>, I>>(base?: I): BytecodeRequest {
    return BytecodeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BytecodeRequest>, I>>(object: I): BytecodeRequest {
    const message = createBaseBytecodeRequest();
    message.id = (object.id !== undefined && object.id !== null) ? AlkaneId.fromPartial(object.id) : undefined;
    return message;
  },
};

function createBaseBlockRequest(): BlockRequest {
  return { height: 0 };
}

export const BlockRequest: MessageFns<BlockRequest> = {
  encode(message: BlockRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.height !== 0) {
      writer.uint32(8).uint32(message.height);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.height = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockRequest {
    return { height: isSet(object.height) ? globalThis.Number(object.height) : 0 };
  },

  toJSON(message: BlockRequest): unknown {
    const obj: any = {};
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockRequest>, I>>(base?: I): BlockRequest {
    return BlockRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockRequest>, I>>(object: I): BlockRequest {
    const message = createBaseBlockRequest();
    message.height = object.height ?? 0;
    return message;
  },
};

function createBaseBlockResponse(): BlockResponse {
  return { block: new Uint8Array(0), height: 0 };
}

export const BlockResponse: MessageFns<BlockResponse> = {
  encode(message: BlockResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.block.length !== 0) {
      writer.uint32(10).bytes(message.block);
    }
    if (message.height !== 0) {
      writer.uint32(16).uint32(message.height);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.block = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.height = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockResponse {
    return {
      block: isSet(object.block) ? bytesFromBase64(object.block) : new Uint8Array(0),
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
    };
  },

  toJSON(message: BlockResponse): unknown {
    const obj: any = {};
    if (message.block.length !== 0) {
      obj.block = base64FromBytes(message.block);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockResponse>, I>>(base?: I): BlockResponse {
    return BlockResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockResponse>, I>>(object: I): BlockResponse {
    const message = createBaseBlockResponse();
    message.block = object.block ?? new Uint8Array(0);
    message.height = object.height ?? 0;
    return message;
  },
};

function createBasePendingUnwrapsRequest(): PendingUnwrapsRequest {
  return { height: 0 };
}

export const PendingUnwrapsRequest: MessageFns<PendingUnwrapsRequest> = {
  encode(message: PendingUnwrapsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.height !== 0) {
      writer.uint32(8).uint32(message.height);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PendingUnwrapsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePendingUnwrapsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.height = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PendingUnwrapsRequest {
    return { height: isSet(object.height) ? globalThis.Number(object.height) : 0 };
  },

  toJSON(message: PendingUnwrapsRequest): unknown {
    const obj: any = {};
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PendingUnwrapsRequest>, I>>(base?: I): PendingUnwrapsRequest {
    return PendingUnwrapsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PendingUnwrapsRequest>, I>>(object: I): PendingUnwrapsRequest {
    const message = createBasePendingUnwrapsRequest();
    message.height = object.height ?? 0;
    return message;
  },
};

function createBasePayment(): Payment {
  return { spendable: undefined, output: new Uint8Array(0), fulfilled: false };
}

export const Payment: MessageFns<Payment> = {
  encode(message: Payment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.spendable !== undefined) {
      Outpoint.encode(message.spendable, writer.uint32(10).fork()).join();
    }
    if (message.output.length !== 0) {
      writer.uint32(18).bytes(message.output);
    }
    if (message.fulfilled !== false) {
      writer.uint32(24).bool(message.fulfilled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Payment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.spendable = Outpoint.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.output = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.fulfilled = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Payment {
    return {
      spendable: isSet(object.spendable) ? Outpoint.fromJSON(object.spendable) : undefined,
      output: isSet(object.output) ? bytesFromBase64(object.output) : new Uint8Array(0),
      fulfilled: isSet(object.fulfilled) ? globalThis.Boolean(object.fulfilled) : false,
    };
  },

  toJSON(message: Payment): unknown {
    const obj: any = {};
    if (message.spendable !== undefined) {
      obj.spendable = Outpoint.toJSON(message.spendable);
    }
    if (message.output.length !== 0) {
      obj.output = base64FromBytes(message.output);
    }
    if (message.fulfilled !== false) {
      obj.fulfilled = message.fulfilled;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Payment>, I>>(base?: I): Payment {
    return Payment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Payment>, I>>(object: I): Payment {
    const message = createBasePayment();
    message.spendable = (object.spendable !== undefined && object.spendable !== null)
      ? Outpoint.fromPartial(object.spendable)
      : undefined;
    message.output = object.output ?? new Uint8Array(0);
    message.fulfilled = object.fulfilled ?? false;
    return message;
  },
};

function createBasePendingUnwrapsResponse(): PendingUnwrapsResponse {
  return { payments: [] };
}

export const PendingUnwrapsResponse: MessageFns<PendingUnwrapsResponse> = {
  encode(message: PendingUnwrapsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.payments) {
      Payment.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PendingUnwrapsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePendingUnwrapsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payments.push(Payment.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PendingUnwrapsResponse {
    return {
      payments: globalThis.Array.isArray(object?.payments) ? object.payments.map((e: any) => Payment.fromJSON(e)) : [],
    };
  },

  toJSON(message: PendingUnwrapsResponse): unknown {
    const obj: any = {};
    if (message.payments?.length) {
      obj.payments = message.payments.map((e) => Payment.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PendingUnwrapsResponse>, I>>(base?: I): PendingUnwrapsResponse {
    return PendingUnwrapsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PendingUnwrapsResponse>, I>>(object: I): PendingUnwrapsResponse {
    const message = createBasePendingUnwrapsResponse();
    message.payments = object.payments?.map((e) => Payment.fromPartial(e)) || [];
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
