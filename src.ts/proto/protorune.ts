// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v6.32.0
// source: protorune.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "protorune";

export interface RuneId {
  height: number;
  txindex: number;
}

export interface TransactionRecord {
  height: bigint;
  transaction: Uint8Array;
}

export interface ProtoruneRuneId {
  height: uint128 | undefined;
  txindex: uint128 | undefined;
}

export interface Rune {
  runeId: ProtoruneRuneId | undefined;
  name: string;
  divisibility: number;
  spacers: number;
  symbol: string;
  runesSymbol: number;
}

export interface BalanceSheetItem {
  rune: Rune | undefined;
  balance: uint128 | undefined;
}

export interface BalanceSheet {
  entries: BalanceSheetItem[];
}

export interface Outpoint {
  txid: Uint8Array;
  vout: number;
}

export interface OutpointWithProtocol {
  txid: Uint8Array;
  vout: number;
  protocol: uint128 | undefined;
}

export interface Output {
  script: Uint8Array;
  value: bigint;
}

export interface OutpointResponse {
  balances: BalanceSheet | undefined;
  outpoint: Outpoint | undefined;
  output: Output | undefined;
  height: number;
  txindex: number;
}

export interface PaginationInput {
  start: number;
  end: number;
}

export interface WalletRequest {
  wallet: Uint8Array;
}

export interface WalletResponse {
  outpoints: OutpointResponse[];
  balances: BalanceSheet | undefined;
}

export interface ProtorunesWalletRequest {
  wallet: Uint8Array;
  protocolTag: uint128 | undefined;
}

export interface RunesByHeightRequest {
  height: bigint;
}

export interface RunesResponse {
  runes: Rune[];
}

export interface ProtoBurn {
  protocolTag: uint128 | undefined;
  pointer: number;
}

export interface uint128 {
  lo: bigint;
  hi: bigint;
}

export interface Clause {
  rune: ProtoruneRuneId | undefined;
  amount: uint128 | undefined;
}

export interface Predicate {
  clauses: Clause[];
}

export interface ProtoMessage {
  calldata: Uint8Array;
  predicate: Predicate | undefined;
  pointer: number;
  refundPointer: number;
}

export interface RuntimeInput {
  protocolTag: uint128 | undefined;
}

export interface Runtime {
  balances: BalanceSheet | undefined;
}

export interface ProtorunesByHeightRequest {
  height: bigint;
  protocolTag: uint128 | undefined;
}

function createBaseRuneId(): RuneId {
  return { height: 0, txindex: 0 };
}

export const RuneId: MessageFns<RuneId> = {
  encode(message: RuneId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.height !== 0) {
      writer.uint32(8).uint32(message.height);
    }
    if (message.txindex !== 0) {
      writer.uint32(16).uint32(message.txindex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RuneId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuneId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.height = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.txindex = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuneId {
    return {
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      txindex: isSet(object.txindex) ? globalThis.Number(object.txindex) : 0,
    };
  },

  toJSON(message: RuneId): unknown {
    const obj: any = {};
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.txindex !== 0) {
      obj.txindex = Math.round(message.txindex);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RuneId>, I>>(base?: I): RuneId {
    return RuneId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RuneId>, I>>(object: I): RuneId {
    const message = createBaseRuneId();
    message.height = object.height ?? 0;
    message.txindex = object.txindex ?? 0;
    return message;
  },
};

function createBaseTransactionRecord(): TransactionRecord {
  return { height: 0n, transaction: new Uint8Array(0) };
}

export const TransactionRecord: MessageFns<TransactionRecord> = {
  encode(message: TransactionRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.height !== 0n) {
      if (BigInt.asUintN(64, message.height) !== message.height) {
        throw new globalThis.Error("value provided for field message.height of type uint64 too large");
      }
      writer.uint32(8).uint64(message.height);
    }
    if (message.transaction.length !== 0) {
      writer.uint32(18).bytes(message.transaction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.height = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.transaction = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionRecord {
    return {
      height: isSet(object.height) ? BigInt(object.height) : 0n,
      transaction: isSet(object.transaction) ? bytesFromBase64(object.transaction) : new Uint8Array(0),
    };
  },

  toJSON(message: TransactionRecord): unknown {
    const obj: any = {};
    if (message.height !== 0n) {
      obj.height = message.height.toString();
    }
    if (message.transaction.length !== 0) {
      obj.transaction = base64FromBytes(message.transaction);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionRecord>, I>>(base?: I): TransactionRecord {
    return TransactionRecord.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionRecord>, I>>(object: I): TransactionRecord {
    const message = createBaseTransactionRecord();
    message.height = object.height ?? 0n;
    message.transaction = object.transaction ?? new Uint8Array(0);
    return message;
  },
};

function createBaseProtoruneRuneId(): ProtoruneRuneId {
  return { height: undefined, txindex: undefined };
}

export const ProtoruneRuneId: MessageFns<ProtoruneRuneId> = {
  encode(message: ProtoruneRuneId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.height !== undefined) {
      uint128.encode(message.height, writer.uint32(10).fork()).join();
    }
    if (message.txindex !== undefined) {
      uint128.encode(message.txindex, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoruneRuneId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoruneRuneId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.height = uint128.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.txindex = uint128.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoruneRuneId {
    return {
      height: isSet(object.height) ? uint128.fromJSON(object.height) : undefined,
      txindex: isSet(object.txindex) ? uint128.fromJSON(object.txindex) : undefined,
    };
  },

  toJSON(message: ProtoruneRuneId): unknown {
    const obj: any = {};
    if (message.height !== undefined) {
      obj.height = uint128.toJSON(message.height);
    }
    if (message.txindex !== undefined) {
      obj.txindex = uint128.toJSON(message.txindex);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoruneRuneId>, I>>(base?: I): ProtoruneRuneId {
    return ProtoruneRuneId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoruneRuneId>, I>>(object: I): ProtoruneRuneId {
    const message = createBaseProtoruneRuneId();
    message.height = (object.height !== undefined && object.height !== null)
      ? uint128.fromPartial(object.height)
      : undefined;
    message.txindex = (object.txindex !== undefined && object.txindex !== null)
      ? uint128.fromPartial(object.txindex)
      : undefined;
    return message;
  },
};

function createBaseRune(): Rune {
  return { runeId: undefined, name: "", divisibility: 0, spacers: 0, symbol: "", runesSymbol: 0 };
}

export const Rune: MessageFns<Rune> = {
  encode(message: Rune, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.runeId !== undefined) {
      ProtoruneRuneId.encode(message.runeId, writer.uint32(10).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.divisibility !== 0) {
      writer.uint32(24).uint32(message.divisibility);
    }
    if (message.spacers !== 0) {
      writer.uint32(32).uint32(message.spacers);
    }
    if (message.symbol !== "") {
      writer.uint32(42).string(message.symbol);
    }
    if (message.runesSymbol !== 0) {
      writer.uint32(48).uint32(message.runesSymbol);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Rune {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRune();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.runeId = ProtoruneRuneId.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.divisibility = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.spacers = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.runesSymbol = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Rune {
    return {
      runeId: isSet(object.runeId) ? ProtoruneRuneId.fromJSON(object.runeId) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      divisibility: isSet(object.divisibility) ? globalThis.Number(object.divisibility) : 0,
      spacers: isSet(object.spacers) ? globalThis.Number(object.spacers) : 0,
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      runesSymbol: isSet(object.runesSymbol) ? globalThis.Number(object.runesSymbol) : 0,
    };
  },

  toJSON(message: Rune): unknown {
    const obj: any = {};
    if (message.runeId !== undefined) {
      obj.runeId = ProtoruneRuneId.toJSON(message.runeId);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.divisibility !== 0) {
      obj.divisibility = Math.round(message.divisibility);
    }
    if (message.spacers !== 0) {
      obj.spacers = Math.round(message.spacers);
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.runesSymbol !== 0) {
      obj.runesSymbol = Math.round(message.runesSymbol);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Rune>, I>>(base?: I): Rune {
    return Rune.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Rune>, I>>(object: I): Rune {
    const message = createBaseRune();
    message.runeId = (object.runeId !== undefined && object.runeId !== null)
      ? ProtoruneRuneId.fromPartial(object.runeId)
      : undefined;
    message.name = object.name ?? "";
    message.divisibility = object.divisibility ?? 0;
    message.spacers = object.spacers ?? 0;
    message.symbol = object.symbol ?? "";
    message.runesSymbol = object.runesSymbol ?? 0;
    return message;
  },
};

function createBaseBalanceSheetItem(): BalanceSheetItem {
  return { rune: undefined, balance: undefined };
}

export const BalanceSheetItem: MessageFns<BalanceSheetItem> = {
  encode(message: BalanceSheetItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rune !== undefined) {
      Rune.encode(message.rune, writer.uint32(10).fork()).join();
    }
    if (message.balance !== undefined) {
      uint128.encode(message.balance, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BalanceSheetItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBalanceSheetItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rune = Rune.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.balance = uint128.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BalanceSheetItem {
    return {
      rune: isSet(object.rune) ? Rune.fromJSON(object.rune) : undefined,
      balance: isSet(object.balance) ? uint128.fromJSON(object.balance) : undefined,
    };
  },

  toJSON(message: BalanceSheetItem): unknown {
    const obj: any = {};
    if (message.rune !== undefined) {
      obj.rune = Rune.toJSON(message.rune);
    }
    if (message.balance !== undefined) {
      obj.balance = uint128.toJSON(message.balance);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BalanceSheetItem>, I>>(base?: I): BalanceSheetItem {
    return BalanceSheetItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BalanceSheetItem>, I>>(object: I): BalanceSheetItem {
    const message = createBaseBalanceSheetItem();
    message.rune = (object.rune !== undefined && object.rune !== null) ? Rune.fromPartial(object.rune) : undefined;
    message.balance = (object.balance !== undefined && object.balance !== null)
      ? uint128.fromPartial(object.balance)
      : undefined;
    return message;
  },
};

function createBaseBalanceSheet(): BalanceSheet {
  return { entries: [] };
}

export const BalanceSheet: MessageFns<BalanceSheet> = {
  encode(message: BalanceSheet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entries) {
      BalanceSheetItem.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BalanceSheet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBalanceSheet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entries.push(BalanceSheetItem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BalanceSheet {
    return {
      entries: globalThis.Array.isArray(object?.entries)
        ? object.entries.map((e: any) => BalanceSheetItem.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BalanceSheet): unknown {
    const obj: any = {};
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => BalanceSheetItem.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BalanceSheet>, I>>(base?: I): BalanceSheet {
    return BalanceSheet.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BalanceSheet>, I>>(object: I): BalanceSheet {
    const message = createBaseBalanceSheet();
    message.entries = object.entries?.map((e) => BalanceSheetItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOutpoint(): Outpoint {
  return { txid: new Uint8Array(0), vout: 0 };
}

export const Outpoint: MessageFns<Outpoint> = {
  encode(message: Outpoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.txid.length !== 0) {
      writer.uint32(10).bytes(message.txid);
    }
    if (message.vout !== 0) {
      writer.uint32(16).uint32(message.vout);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Outpoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutpoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.txid = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.vout = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Outpoint {
    return {
      txid: isSet(object.txid) ? bytesFromBase64(object.txid) : new Uint8Array(0),
      vout: isSet(object.vout) ? globalThis.Number(object.vout) : 0,
    };
  },

  toJSON(message: Outpoint): unknown {
    const obj: any = {};
    if (message.txid.length !== 0) {
      obj.txid = base64FromBytes(message.txid);
    }
    if (message.vout !== 0) {
      obj.vout = Math.round(message.vout);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Outpoint>, I>>(base?: I): Outpoint {
    return Outpoint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Outpoint>, I>>(object: I): Outpoint {
    const message = createBaseOutpoint();
    message.txid = object.txid ?? new Uint8Array(0);
    message.vout = object.vout ?? 0;
    return message;
  },
};

function createBaseOutpointWithProtocol(): OutpointWithProtocol {
  return { txid: new Uint8Array(0), vout: 0, protocol: undefined };
}

export const OutpointWithProtocol: MessageFns<OutpointWithProtocol> = {
  encode(message: OutpointWithProtocol, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.txid.length !== 0) {
      writer.uint32(10).bytes(message.txid);
    }
    if (message.vout !== 0) {
      writer.uint32(16).uint32(message.vout);
    }
    if (message.protocol !== undefined) {
      uint128.encode(message.protocol, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OutpointWithProtocol {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutpointWithProtocol();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.txid = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.vout = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.protocol = uint128.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutpointWithProtocol {
    return {
      txid: isSet(object.txid) ? bytesFromBase64(object.txid) : new Uint8Array(0),
      vout: isSet(object.vout) ? globalThis.Number(object.vout) : 0,
      protocol: isSet(object.protocol) ? uint128.fromJSON(object.protocol) : undefined,
    };
  },

  toJSON(message: OutpointWithProtocol): unknown {
    const obj: any = {};
    if (message.txid.length !== 0) {
      obj.txid = base64FromBytes(message.txid);
    }
    if (message.vout !== 0) {
      obj.vout = Math.round(message.vout);
    }
    if (message.protocol !== undefined) {
      obj.protocol = uint128.toJSON(message.protocol);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OutpointWithProtocol>, I>>(base?: I): OutpointWithProtocol {
    return OutpointWithProtocol.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OutpointWithProtocol>, I>>(object: I): OutpointWithProtocol {
    const message = createBaseOutpointWithProtocol();
    message.txid = object.txid ?? new Uint8Array(0);
    message.vout = object.vout ?? 0;
    message.protocol = (object.protocol !== undefined && object.protocol !== null)
      ? uint128.fromPartial(object.protocol)
      : undefined;
    return message;
  },
};

function createBaseOutput(): Output {
  return { script: new Uint8Array(0), value: 0n };
}

export const Output: MessageFns<Output> = {
  encode(message: Output, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.script.length !== 0) {
      writer.uint32(10).bytes(message.script);
    }
    if (message.value !== 0n) {
      if (BigInt.asUintN(64, message.value) !== message.value) {
        throw new globalThis.Error("value provided for field message.value of type uint64 too large");
      }
      writer.uint32(16).uint64(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Output {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.script = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Output {
    return {
      script: isSet(object.script) ? bytesFromBase64(object.script) : new Uint8Array(0),
      value: isSet(object.value) ? BigInt(object.value) : 0n,
    };
  },

  toJSON(message: Output): unknown {
    const obj: any = {};
    if (message.script.length !== 0) {
      obj.script = base64FromBytes(message.script);
    }
    if (message.value !== 0n) {
      obj.value = message.value.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Output>, I>>(base?: I): Output {
    return Output.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Output>, I>>(object: I): Output {
    const message = createBaseOutput();
    message.script = object.script ?? new Uint8Array(0);
    message.value = object.value ?? 0n;
    return message;
  },
};

function createBaseOutpointResponse(): OutpointResponse {
  return { balances: undefined, outpoint: undefined, output: undefined, height: 0, txindex: 0 };
}

export const OutpointResponse: MessageFns<OutpointResponse> = {
  encode(message: OutpointResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.balances !== undefined) {
      BalanceSheet.encode(message.balances, writer.uint32(10).fork()).join();
    }
    if (message.outpoint !== undefined) {
      Outpoint.encode(message.outpoint, writer.uint32(18).fork()).join();
    }
    if (message.output !== undefined) {
      Output.encode(message.output, writer.uint32(26).fork()).join();
    }
    if (message.height !== 0) {
      writer.uint32(32).uint32(message.height);
    }
    if (message.txindex !== 0) {
      writer.uint32(40).uint32(message.txindex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OutpointResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutpointResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.balances = BalanceSheet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.outpoint = Outpoint.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.output = Output.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.height = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.txindex = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutpointResponse {
    return {
      balances: isSet(object.balances) ? BalanceSheet.fromJSON(object.balances) : undefined,
      outpoint: isSet(object.outpoint) ? Outpoint.fromJSON(object.outpoint) : undefined,
      output: isSet(object.output) ? Output.fromJSON(object.output) : undefined,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      txindex: isSet(object.txindex) ? globalThis.Number(object.txindex) : 0,
    };
  },

  toJSON(message: OutpointResponse): unknown {
    const obj: any = {};
    if (message.balances !== undefined) {
      obj.balances = BalanceSheet.toJSON(message.balances);
    }
    if (message.outpoint !== undefined) {
      obj.outpoint = Outpoint.toJSON(message.outpoint);
    }
    if (message.output !== undefined) {
      obj.output = Output.toJSON(message.output);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.txindex !== 0) {
      obj.txindex = Math.round(message.txindex);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OutpointResponse>, I>>(base?: I): OutpointResponse {
    return OutpointResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OutpointResponse>, I>>(object: I): OutpointResponse {
    const message = createBaseOutpointResponse();
    message.balances = (object.balances !== undefined && object.balances !== null)
      ? BalanceSheet.fromPartial(object.balances)
      : undefined;
    message.outpoint = (object.outpoint !== undefined && object.outpoint !== null)
      ? Outpoint.fromPartial(object.outpoint)
      : undefined;
    message.output = (object.output !== undefined && object.output !== null)
      ? Output.fromPartial(object.output)
      : undefined;
    message.height = object.height ?? 0;
    message.txindex = object.txindex ?? 0;
    return message;
  },
};

function createBasePaginationInput(): PaginationInput {
  return { start: 0, end: 0 };
}

export const PaginationInput: MessageFns<PaginationInput> = {
  encode(message: PaginationInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.start !== 0) {
      writer.uint32(8).uint32(message.start);
    }
    if (message.end !== 0) {
      writer.uint32(16).uint32(message.end);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaginationInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaginationInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.start = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.end = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaginationInput {
    return {
      start: isSet(object.start) ? globalThis.Number(object.start) : 0,
      end: isSet(object.end) ? globalThis.Number(object.end) : 0,
    };
  },

  toJSON(message: PaginationInput): unknown {
    const obj: any = {};
    if (message.start !== 0) {
      obj.start = Math.round(message.start);
    }
    if (message.end !== 0) {
      obj.end = Math.round(message.end);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaginationInput>, I>>(base?: I): PaginationInput {
    return PaginationInput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaginationInput>, I>>(object: I): PaginationInput {
    const message = createBasePaginationInput();
    message.start = object.start ?? 0;
    message.end = object.end ?? 0;
    return message;
  },
};

function createBaseWalletRequest(): WalletRequest {
  return { wallet: new Uint8Array(0) };
}

export const WalletRequest: MessageFns<WalletRequest> = {
  encode(message: WalletRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.wallet.length !== 0) {
      writer.uint32(10).bytes(message.wallet);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WalletRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWalletRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.wallet = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WalletRequest {
    return { wallet: isSet(object.wallet) ? bytesFromBase64(object.wallet) : new Uint8Array(0) };
  },

  toJSON(message: WalletRequest): unknown {
    const obj: any = {};
    if (message.wallet.length !== 0) {
      obj.wallet = base64FromBytes(message.wallet);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WalletRequest>, I>>(base?: I): WalletRequest {
    return WalletRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WalletRequest>, I>>(object: I): WalletRequest {
    const message = createBaseWalletRequest();
    message.wallet = object.wallet ?? new Uint8Array(0);
    return message;
  },
};

function createBaseWalletResponse(): WalletResponse {
  return { outpoints: [], balances: undefined };
}

export const WalletResponse: MessageFns<WalletResponse> = {
  encode(message: WalletResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.outpoints) {
      OutpointResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.balances !== undefined) {
      BalanceSheet.encode(message.balances, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WalletResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWalletResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.outpoints.push(OutpointResponse.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.balances = BalanceSheet.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WalletResponse {
    return {
      outpoints: globalThis.Array.isArray(object?.outpoints)
        ? object.outpoints.map((e: any) => OutpointResponse.fromJSON(e))
        : [],
      balances: isSet(object.balances) ? BalanceSheet.fromJSON(object.balances) : undefined,
    };
  },

  toJSON(message: WalletResponse): unknown {
    const obj: any = {};
    if (message.outpoints?.length) {
      obj.outpoints = message.outpoints.map((e) => OutpointResponse.toJSON(e));
    }
    if (message.balances !== undefined) {
      obj.balances = BalanceSheet.toJSON(message.balances);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WalletResponse>, I>>(base?: I): WalletResponse {
    return WalletResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WalletResponse>, I>>(object: I): WalletResponse {
    const message = createBaseWalletResponse();
    message.outpoints = object.outpoints?.map((e) => OutpointResponse.fromPartial(e)) || [];
    message.balances = (object.balances !== undefined && object.balances !== null)
      ? BalanceSheet.fromPartial(object.balances)
      : undefined;
    return message;
  },
};

function createBaseProtorunesWalletRequest(): ProtorunesWalletRequest {
  return { wallet: new Uint8Array(0), protocolTag: undefined };
}

export const ProtorunesWalletRequest: MessageFns<ProtorunesWalletRequest> = {
  encode(message: ProtorunesWalletRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.wallet.length !== 0) {
      writer.uint32(10).bytes(message.wallet);
    }
    if (message.protocolTag !== undefined) {
      uint128.encode(message.protocolTag, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtorunesWalletRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtorunesWalletRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.wallet = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.protocolTag = uint128.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtorunesWalletRequest {
    return {
      wallet: isSet(object.wallet) ? bytesFromBase64(object.wallet) : new Uint8Array(0),
      protocolTag: isSet(object.protocolTag) ? uint128.fromJSON(object.protocolTag) : undefined,
    };
  },

  toJSON(message: ProtorunesWalletRequest): unknown {
    const obj: any = {};
    if (message.wallet.length !== 0) {
      obj.wallet = base64FromBytes(message.wallet);
    }
    if (message.protocolTag !== undefined) {
      obj.protocolTag = uint128.toJSON(message.protocolTag);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtorunesWalletRequest>, I>>(base?: I): ProtorunesWalletRequest {
    return ProtorunesWalletRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtorunesWalletRequest>, I>>(object: I): ProtorunesWalletRequest {
    const message = createBaseProtorunesWalletRequest();
    message.wallet = object.wallet ?? new Uint8Array(0);
    message.protocolTag = (object.protocolTag !== undefined && object.protocolTag !== null)
      ? uint128.fromPartial(object.protocolTag)
      : undefined;
    return message;
  },
};

function createBaseRunesByHeightRequest(): RunesByHeightRequest {
  return { height: 0n };
}

export const RunesByHeightRequest: MessageFns<RunesByHeightRequest> = {
  encode(message: RunesByHeightRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.height !== 0n) {
      if (BigInt.asUintN(64, message.height) !== message.height) {
        throw new globalThis.Error("value provided for field message.height of type uint64 too large");
      }
      writer.uint32(8).uint64(message.height);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunesByHeightRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunesByHeightRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.height = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunesByHeightRequest {
    return { height: isSet(object.height) ? BigInt(object.height) : 0n };
  },

  toJSON(message: RunesByHeightRequest): unknown {
    const obj: any = {};
    if (message.height !== 0n) {
      obj.height = message.height.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RunesByHeightRequest>, I>>(base?: I): RunesByHeightRequest {
    return RunesByHeightRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunesByHeightRequest>, I>>(object: I): RunesByHeightRequest {
    const message = createBaseRunesByHeightRequest();
    message.height = object.height ?? 0n;
    return message;
  },
};

function createBaseRunesResponse(): RunesResponse {
  return { runes: [] };
}

export const RunesResponse: MessageFns<RunesResponse> = {
  encode(message: RunesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.runes) {
      Rune.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.runes.push(Rune.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunesResponse {
    return { runes: globalThis.Array.isArray(object?.runes) ? object.runes.map((e: any) => Rune.fromJSON(e)) : [] };
  },

  toJSON(message: RunesResponse): unknown {
    const obj: any = {};
    if (message.runes?.length) {
      obj.runes = message.runes.map((e) => Rune.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RunesResponse>, I>>(base?: I): RunesResponse {
    return RunesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunesResponse>, I>>(object: I): RunesResponse {
    const message = createBaseRunesResponse();
    message.runes = object.runes?.map((e) => Rune.fromPartial(e)) || [];
    return message;
  },
};

function createBaseProtoBurn(): ProtoBurn {
  return { protocolTag: undefined, pointer: 0 };
}

export const ProtoBurn: MessageFns<ProtoBurn> = {
  encode(message: ProtoBurn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.protocolTag !== undefined) {
      uint128.encode(message.protocolTag, writer.uint32(10).fork()).join();
    }
    if (message.pointer !== 0) {
      writer.uint32(16).uint32(message.pointer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoBurn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoBurn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.protocolTag = uint128.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pointer = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoBurn {
    return {
      protocolTag: isSet(object.protocolTag) ? uint128.fromJSON(object.protocolTag) : undefined,
      pointer: isSet(object.pointer) ? globalThis.Number(object.pointer) : 0,
    };
  },

  toJSON(message: ProtoBurn): unknown {
    const obj: any = {};
    if (message.protocolTag !== undefined) {
      obj.protocolTag = uint128.toJSON(message.protocolTag);
    }
    if (message.pointer !== 0) {
      obj.pointer = Math.round(message.pointer);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoBurn>, I>>(base?: I): ProtoBurn {
    return ProtoBurn.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoBurn>, I>>(object: I): ProtoBurn {
    const message = createBaseProtoBurn();
    message.protocolTag = (object.protocolTag !== undefined && object.protocolTag !== null)
      ? uint128.fromPartial(object.protocolTag)
      : undefined;
    message.pointer = object.pointer ?? 0;
    return message;
  },
};

function createBaseuint128(): uint128 {
  return { lo: 0n, hi: 0n };
}

export const uint128: MessageFns<uint128> = {
  encode(message: uint128, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lo !== 0n) {
      if (BigInt.asUintN(64, message.lo) !== message.lo) {
        throw new globalThis.Error("value provided for field message.lo of type uint64 too large");
      }
      writer.uint32(8).uint64(message.lo);
    }
    if (message.hi !== 0n) {
      if (BigInt.asUintN(64, message.hi) !== message.hi) {
        throw new globalThis.Error("value provided for field message.hi of type uint64 too large");
      }
      writer.uint32(16).uint64(message.hi);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): uint128 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseuint128();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.lo = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.hi = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): uint128 {
    return { lo: isSet(object.lo) ? BigInt(object.lo) : 0n, hi: isSet(object.hi) ? BigInt(object.hi) : 0n };
  },

  toJSON(message: uint128): unknown {
    const obj: any = {};
    if (message.lo !== 0n) {
      obj.lo = message.lo.toString();
    }
    if (message.hi !== 0n) {
      obj.hi = message.hi.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<uint128>, I>>(base?: I): uint128 {
    return uint128.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<uint128>, I>>(object: I): uint128 {
    const message = createBaseuint128();
    message.lo = object.lo ?? 0n;
    message.hi = object.hi ?? 0n;
    return message;
  },
};

function createBaseClause(): Clause {
  return { rune: undefined, amount: undefined };
}

export const Clause: MessageFns<Clause> = {
  encode(message: Clause, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rune !== undefined) {
      ProtoruneRuneId.encode(message.rune, writer.uint32(10).fork()).join();
    }
    if (message.amount !== undefined) {
      uint128.encode(message.amount, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Clause {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClause();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rune = ProtoruneRuneId.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.amount = uint128.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Clause {
    return {
      rune: isSet(object.rune) ? ProtoruneRuneId.fromJSON(object.rune) : undefined,
      amount: isSet(object.amount) ? uint128.fromJSON(object.amount) : undefined,
    };
  },

  toJSON(message: Clause): unknown {
    const obj: any = {};
    if (message.rune !== undefined) {
      obj.rune = ProtoruneRuneId.toJSON(message.rune);
    }
    if (message.amount !== undefined) {
      obj.amount = uint128.toJSON(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Clause>, I>>(base?: I): Clause {
    return Clause.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Clause>, I>>(object: I): Clause {
    const message = createBaseClause();
    message.rune = (object.rune !== undefined && object.rune !== null)
      ? ProtoruneRuneId.fromPartial(object.rune)
      : undefined;
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? uint128.fromPartial(object.amount)
      : undefined;
    return message;
  },
};

function createBasePredicate(): Predicate {
  return { clauses: [] };
}

export const Predicate: MessageFns<Predicate> = {
  encode(message: Predicate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.clauses) {
      Clause.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Predicate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePredicate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clauses.push(Clause.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Predicate {
    return {
      clauses: globalThis.Array.isArray(object?.clauses) ? object.clauses.map((e: any) => Clause.fromJSON(e)) : [],
    };
  },

  toJSON(message: Predicate): unknown {
    const obj: any = {};
    if (message.clauses?.length) {
      obj.clauses = message.clauses.map((e) => Clause.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Predicate>, I>>(base?: I): Predicate {
    return Predicate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Predicate>, I>>(object: I): Predicate {
    const message = createBasePredicate();
    message.clauses = object.clauses?.map((e) => Clause.fromPartial(e)) || [];
    return message;
  },
};

function createBaseProtoMessage(): ProtoMessage {
  return { calldata: new Uint8Array(0), predicate: undefined, pointer: 0, refundPointer: 0 };
}

export const ProtoMessage: MessageFns<ProtoMessage> = {
  encode(message: ProtoMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.calldata.length !== 0) {
      writer.uint32(10).bytes(message.calldata);
    }
    if (message.predicate !== undefined) {
      Predicate.encode(message.predicate, writer.uint32(18).fork()).join();
    }
    if (message.pointer !== 0) {
      writer.uint32(24).uint32(message.pointer);
    }
    if (message.refundPointer !== 0) {
      writer.uint32(32).uint32(message.refundPointer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.calldata = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.predicate = Predicate.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pointer = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.refundPointer = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoMessage {
    return {
      calldata: isSet(object.calldata) ? bytesFromBase64(object.calldata) : new Uint8Array(0),
      predicate: isSet(object.predicate) ? Predicate.fromJSON(object.predicate) : undefined,
      pointer: isSet(object.pointer) ? globalThis.Number(object.pointer) : 0,
      refundPointer: isSet(object.refundPointer) ? globalThis.Number(object.refundPointer) : 0,
    };
  },

  toJSON(message: ProtoMessage): unknown {
    const obj: any = {};
    if (message.calldata.length !== 0) {
      obj.calldata = base64FromBytes(message.calldata);
    }
    if (message.predicate !== undefined) {
      obj.predicate = Predicate.toJSON(message.predicate);
    }
    if (message.pointer !== 0) {
      obj.pointer = Math.round(message.pointer);
    }
    if (message.refundPointer !== 0) {
      obj.refundPointer = Math.round(message.refundPointer);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoMessage>, I>>(base?: I): ProtoMessage {
    return ProtoMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoMessage>, I>>(object: I): ProtoMessage {
    const message = createBaseProtoMessage();
    message.calldata = object.calldata ?? new Uint8Array(0);
    message.predicate = (object.predicate !== undefined && object.predicate !== null)
      ? Predicate.fromPartial(object.predicate)
      : undefined;
    message.pointer = object.pointer ?? 0;
    message.refundPointer = object.refundPointer ?? 0;
    return message;
  },
};

function createBaseRuntimeInput(): RuntimeInput {
  return { protocolTag: undefined };
}

export const RuntimeInput: MessageFns<RuntimeInput> = {
  encode(message: RuntimeInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.protocolTag !== undefined) {
      uint128.encode(message.protocolTag, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RuntimeInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuntimeInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.protocolTag = uint128.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuntimeInput {
    return { protocolTag: isSet(object.protocolTag) ? uint128.fromJSON(object.protocolTag) : undefined };
  },

  toJSON(message: RuntimeInput): unknown {
    const obj: any = {};
    if (message.protocolTag !== undefined) {
      obj.protocolTag = uint128.toJSON(message.protocolTag);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RuntimeInput>, I>>(base?: I): RuntimeInput {
    return RuntimeInput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RuntimeInput>, I>>(object: I): RuntimeInput {
    const message = createBaseRuntimeInput();
    message.protocolTag = (object.protocolTag !== undefined && object.protocolTag !== null)
      ? uint128.fromPartial(object.protocolTag)
      : undefined;
    return message;
  },
};

function createBaseRuntime(): Runtime {
  return { balances: undefined };
}

export const Runtime: MessageFns<Runtime> = {
  encode(message: Runtime, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.balances !== undefined) {
      BalanceSheet.encode(message.balances, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Runtime {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuntime();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.balances = BalanceSheet.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Runtime {
    return { balances: isSet(object.balances) ? BalanceSheet.fromJSON(object.balances) : undefined };
  },

  toJSON(message: Runtime): unknown {
    const obj: any = {};
    if (message.balances !== undefined) {
      obj.balances = BalanceSheet.toJSON(message.balances);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Runtime>, I>>(base?: I): Runtime {
    return Runtime.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Runtime>, I>>(object: I): Runtime {
    const message = createBaseRuntime();
    message.balances = (object.balances !== undefined && object.balances !== null)
      ? BalanceSheet.fromPartial(object.balances)
      : undefined;
    return message;
  },
};

function createBaseProtorunesByHeightRequest(): ProtorunesByHeightRequest {
  return { height: 0n, protocolTag: undefined };
}

export const ProtorunesByHeightRequest: MessageFns<ProtorunesByHeightRequest> = {
  encode(message: ProtorunesByHeightRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.height !== 0n) {
      if (BigInt.asUintN(64, message.height) !== message.height) {
        throw new globalThis.Error("value provided for field message.height of type uint64 too large");
      }
      writer.uint32(8).uint64(message.height);
    }
    if (message.protocolTag !== undefined) {
      uint128.encode(message.protocolTag, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtorunesByHeightRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtorunesByHeightRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.height = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.protocolTag = uint128.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtorunesByHeightRequest {
    return {
      height: isSet(object.height) ? BigInt(object.height) : 0n,
      protocolTag: isSet(object.protocolTag) ? uint128.fromJSON(object.protocolTag) : undefined,
    };
  },

  toJSON(message: ProtorunesByHeightRequest): unknown {
    const obj: any = {};
    if (message.height !== 0n) {
      obj.height = message.height.toString();
    }
    if (message.protocolTag !== undefined) {
      obj.protocolTag = uint128.toJSON(message.protocolTag);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtorunesByHeightRequest>, I>>(base?: I): ProtorunesByHeightRequest {
    return ProtorunesByHeightRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtorunesByHeightRequest>, I>>(object: I): ProtorunesByHeightRequest {
    const message = createBaseProtorunesByHeightRequest();
    message.height = object.height ?? 0n;
    message.protocolTag = (object.protocolTag !== undefined && object.protocolTag !== null)
      ? uint128.fromPartial(object.protocolTag)
      : undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
