"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v6.32.0
// source: protorune.proto
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProtorunesByHeightRequest = exports.Runtime = exports.RuntimeInput = exports.ProtoMessage = exports.Predicate = exports.Clause = exports.uint128 = exports.ProtoBurn = exports.RunesResponse = exports.RunesByHeightRequest = exports.ProtorunesWalletRequest = exports.WalletResponse = exports.WalletRequest = exports.PaginationInput = exports.OutpointResponse = exports.Output = exports.OutpointWithProtocol = exports.Outpoint = exports.BalanceSheet = exports.BalanceSheetItem = exports.Rune = exports.ProtoruneRuneId = exports.TransactionRecord = exports.RuneId = exports.protobufPackage = void 0;
/* eslint-disable */
const wire_1 = require("@bufbuild/protobuf/wire");
exports.protobufPackage = "protorune";
function createBaseRuneId() {
    return { height: 0, txindex: 0 };
}
exports.RuneId = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.height !== 0) {
            writer.uint32(8).uint32(message.height);
        }
        if (message.txindex !== 0) {
            writer.uint32(16).uint32(message.txindex);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRuneId();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.height = reader.uint32();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.txindex = reader.uint32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            height: isSet(object.height) ? globalThis.Number(object.height) : 0,
            txindex: isSet(object.txindex) ? globalThis.Number(object.txindex) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.height !== 0) {
            obj.height = Math.round(message.height);
        }
        if (message.txindex !== 0) {
            obj.txindex = Math.round(message.txindex);
        }
        return obj;
    },
    create(base) {
        return exports.RuneId.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRuneId();
        message.height = object.height ?? 0;
        message.txindex = object.txindex ?? 0;
        return message;
    },
};
function createBaseTransactionRecord() {
    return { height: 0n, transaction: new Uint8Array(0) };
}
exports.TransactionRecord = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.height !== 0n) {
            if (BigInt.asUintN(64, message.height) !== message.height) {
                throw new globalThis.Error("value provided for field message.height of type uint64 too large");
            }
            writer.uint32(8).uint64(message.height);
        }
        if (message.transaction.length !== 0) {
            writer.uint32(18).bytes(message.transaction);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTransactionRecord();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.height = reader.uint64();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.transaction = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            height: isSet(object.height) ? BigInt(object.height) : 0n,
            transaction: isSet(object.transaction) ? bytesFromBase64(object.transaction) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.height !== 0n) {
            obj.height = message.height.toString();
        }
        if (message.transaction.length !== 0) {
            obj.transaction = base64FromBytes(message.transaction);
        }
        return obj;
    },
    create(base) {
        return exports.TransactionRecord.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTransactionRecord();
        message.height = object.height ?? 0n;
        message.transaction = object.transaction ?? new Uint8Array(0);
        return message;
    },
};
function createBaseProtoruneRuneId() {
    return { height: undefined, txindex: undefined };
}
exports.ProtoruneRuneId = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.height !== undefined) {
            exports.uint128.encode(message.height, writer.uint32(10).fork()).join();
        }
        if (message.txindex !== undefined) {
            exports.uint128.encode(message.txindex, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProtoruneRuneId();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.height = exports.uint128.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.txindex = exports.uint128.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            height: isSet(object.height) ? exports.uint128.fromJSON(object.height) : undefined,
            txindex: isSet(object.txindex) ? exports.uint128.fromJSON(object.txindex) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.height !== undefined) {
            obj.height = exports.uint128.toJSON(message.height);
        }
        if (message.txindex !== undefined) {
            obj.txindex = exports.uint128.toJSON(message.txindex);
        }
        return obj;
    },
    create(base) {
        return exports.ProtoruneRuneId.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseProtoruneRuneId();
        message.height = (object.height !== undefined && object.height !== null)
            ? exports.uint128.fromPartial(object.height)
            : undefined;
        message.txindex = (object.txindex !== undefined && object.txindex !== null)
            ? exports.uint128.fromPartial(object.txindex)
            : undefined;
        return message;
    },
};
function createBaseRune() {
    return { runeId: undefined, name: "", divisibility: 0, spacers: 0, symbol: "", runesSymbol: 0 };
}
exports.Rune = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.runeId !== undefined) {
            exports.ProtoruneRuneId.encode(message.runeId, writer.uint32(10).fork()).join();
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        if (message.divisibility !== 0) {
            writer.uint32(24).uint32(message.divisibility);
        }
        if (message.spacers !== 0) {
            writer.uint32(32).uint32(message.spacers);
        }
        if (message.symbol !== "") {
            writer.uint32(42).string(message.symbol);
        }
        if (message.runesSymbol !== 0) {
            writer.uint32(48).uint32(message.runesSymbol);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRune();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.runeId = exports.ProtoruneRuneId.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.divisibility = reader.uint32();
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.spacers = reader.uint32();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.symbol = reader.string();
                    continue;
                }
                case 6: {
                    if (tag !== 48) {
                        break;
                    }
                    message.runesSymbol = reader.uint32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            runeId: isSet(object.runeId) ? exports.ProtoruneRuneId.fromJSON(object.runeId) : undefined,
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            divisibility: isSet(object.divisibility) ? globalThis.Number(object.divisibility) : 0,
            spacers: isSet(object.spacers) ? globalThis.Number(object.spacers) : 0,
            symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
            runesSymbol: isSet(object.runesSymbol) ? globalThis.Number(object.runesSymbol) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.runeId !== undefined) {
            obj.runeId = exports.ProtoruneRuneId.toJSON(message.runeId);
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.divisibility !== 0) {
            obj.divisibility = Math.round(message.divisibility);
        }
        if (message.spacers !== 0) {
            obj.spacers = Math.round(message.spacers);
        }
        if (message.symbol !== "") {
            obj.symbol = message.symbol;
        }
        if (message.runesSymbol !== 0) {
            obj.runesSymbol = Math.round(message.runesSymbol);
        }
        return obj;
    },
    create(base) {
        return exports.Rune.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRune();
        message.runeId = (object.runeId !== undefined && object.runeId !== null)
            ? exports.ProtoruneRuneId.fromPartial(object.runeId)
            : undefined;
        message.name = object.name ?? "";
        message.divisibility = object.divisibility ?? 0;
        message.spacers = object.spacers ?? 0;
        message.symbol = object.symbol ?? "";
        message.runesSymbol = object.runesSymbol ?? 0;
        return message;
    },
};
function createBaseBalanceSheetItem() {
    return { rune: undefined, balance: undefined };
}
exports.BalanceSheetItem = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.rune !== undefined) {
            exports.Rune.encode(message.rune, writer.uint32(10).fork()).join();
        }
        if (message.balance !== undefined) {
            exports.uint128.encode(message.balance, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBalanceSheetItem();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.rune = exports.Rune.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.balance = exports.uint128.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            rune: isSet(object.rune) ? exports.Rune.fromJSON(object.rune) : undefined,
            balance: isSet(object.balance) ? exports.uint128.fromJSON(object.balance) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.rune !== undefined) {
            obj.rune = exports.Rune.toJSON(message.rune);
        }
        if (message.balance !== undefined) {
            obj.balance = exports.uint128.toJSON(message.balance);
        }
        return obj;
    },
    create(base) {
        return exports.BalanceSheetItem.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBalanceSheetItem();
        message.rune = (object.rune !== undefined && object.rune !== null) ? exports.Rune.fromPartial(object.rune) : undefined;
        message.balance = (object.balance !== undefined && object.balance !== null)
            ? exports.uint128.fromPartial(object.balance)
            : undefined;
        return message;
    },
};
function createBaseBalanceSheet() {
    return { entries: [] };
}
exports.BalanceSheet = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.entries) {
            exports.BalanceSheetItem.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBalanceSheet();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.entries.push(exports.BalanceSheetItem.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            entries: globalThis.Array.isArray(object?.entries)
                ? object.entries.map((e) => exports.BalanceSheetItem.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.entries?.length) {
            obj.entries = message.entries.map((e) => exports.BalanceSheetItem.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.BalanceSheet.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBalanceSheet();
        message.entries = object.entries?.map((e) => exports.BalanceSheetItem.fromPartial(e)) || [];
        return message;
    },
};
function createBaseOutpoint() {
    return { txid: new Uint8Array(0), vout: 0 };
}
exports.Outpoint = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.txid.length !== 0) {
            writer.uint32(10).bytes(message.txid);
        }
        if (message.vout !== 0) {
            writer.uint32(16).uint32(message.vout);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOutpoint();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.txid = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.vout = reader.uint32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            txid: isSet(object.txid) ? bytesFromBase64(object.txid) : new Uint8Array(0),
            vout: isSet(object.vout) ? globalThis.Number(object.vout) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.txid.length !== 0) {
            obj.txid = base64FromBytes(message.txid);
        }
        if (message.vout !== 0) {
            obj.vout = Math.round(message.vout);
        }
        return obj;
    },
    create(base) {
        return exports.Outpoint.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseOutpoint();
        message.txid = object.txid ?? new Uint8Array(0);
        message.vout = object.vout ?? 0;
        return message;
    },
};
function createBaseOutpointWithProtocol() {
    return { txid: new Uint8Array(0), vout: 0, protocol: undefined };
}
exports.OutpointWithProtocol = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.txid.length !== 0) {
            writer.uint32(10).bytes(message.txid);
        }
        if (message.vout !== 0) {
            writer.uint32(16).uint32(message.vout);
        }
        if (message.protocol !== undefined) {
            exports.uint128.encode(message.protocol, writer.uint32(26).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOutpointWithProtocol();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.txid = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.vout = reader.uint32();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.protocol = exports.uint128.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            txid: isSet(object.txid) ? bytesFromBase64(object.txid) : new Uint8Array(0),
            vout: isSet(object.vout) ? globalThis.Number(object.vout) : 0,
            protocol: isSet(object.protocol) ? exports.uint128.fromJSON(object.protocol) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.txid.length !== 0) {
            obj.txid = base64FromBytes(message.txid);
        }
        if (message.vout !== 0) {
            obj.vout = Math.round(message.vout);
        }
        if (message.protocol !== undefined) {
            obj.protocol = exports.uint128.toJSON(message.protocol);
        }
        return obj;
    },
    create(base) {
        return exports.OutpointWithProtocol.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseOutpointWithProtocol();
        message.txid = object.txid ?? new Uint8Array(0);
        message.vout = object.vout ?? 0;
        message.protocol = (object.protocol !== undefined && object.protocol !== null)
            ? exports.uint128.fromPartial(object.protocol)
            : undefined;
        return message;
    },
};
function createBaseOutput() {
    return { script: new Uint8Array(0), value: 0n };
}
exports.Output = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.script.length !== 0) {
            writer.uint32(10).bytes(message.script);
        }
        if (message.value !== 0n) {
            if (BigInt.asUintN(64, message.value) !== message.value) {
                throw new globalThis.Error("value provided for field message.value of type uint64 too large");
            }
            writer.uint32(16).uint64(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOutput();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.script = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.value = reader.uint64();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            script: isSet(object.script) ? bytesFromBase64(object.script) : new Uint8Array(0),
            value: isSet(object.value) ? BigInt(object.value) : 0n,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.script.length !== 0) {
            obj.script = base64FromBytes(message.script);
        }
        if (message.value !== 0n) {
            obj.value = message.value.toString();
        }
        return obj;
    },
    create(base) {
        return exports.Output.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseOutput();
        message.script = object.script ?? new Uint8Array(0);
        message.value = object.value ?? 0n;
        return message;
    },
};
function createBaseOutpointResponse() {
    return { balances: undefined, outpoint: undefined, output: undefined, height: 0, txindex: 0 };
}
exports.OutpointResponse = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.balances !== undefined) {
            exports.BalanceSheet.encode(message.balances, writer.uint32(10).fork()).join();
        }
        if (message.outpoint !== undefined) {
            exports.Outpoint.encode(message.outpoint, writer.uint32(18).fork()).join();
        }
        if (message.output !== undefined) {
            exports.Output.encode(message.output, writer.uint32(26).fork()).join();
        }
        if (message.height !== 0) {
            writer.uint32(32).uint32(message.height);
        }
        if (message.txindex !== 0) {
            writer.uint32(40).uint32(message.txindex);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOutpointResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.balances = exports.BalanceSheet.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.outpoint = exports.Outpoint.decode(reader, reader.uint32());
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.output = exports.Output.decode(reader, reader.uint32());
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.height = reader.uint32();
                    continue;
                }
                case 5: {
                    if (tag !== 40) {
                        break;
                    }
                    message.txindex = reader.uint32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            balances: isSet(object.balances) ? exports.BalanceSheet.fromJSON(object.balances) : undefined,
            outpoint: isSet(object.outpoint) ? exports.Outpoint.fromJSON(object.outpoint) : undefined,
            output: isSet(object.output) ? exports.Output.fromJSON(object.output) : undefined,
            height: isSet(object.height) ? globalThis.Number(object.height) : 0,
            txindex: isSet(object.txindex) ? globalThis.Number(object.txindex) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.balances !== undefined) {
            obj.balances = exports.BalanceSheet.toJSON(message.balances);
        }
        if (message.outpoint !== undefined) {
            obj.outpoint = exports.Outpoint.toJSON(message.outpoint);
        }
        if (message.output !== undefined) {
            obj.output = exports.Output.toJSON(message.output);
        }
        if (message.height !== 0) {
            obj.height = Math.round(message.height);
        }
        if (message.txindex !== 0) {
            obj.txindex = Math.round(message.txindex);
        }
        return obj;
    },
    create(base) {
        return exports.OutpointResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseOutpointResponse();
        message.balances = (object.balances !== undefined && object.balances !== null)
            ? exports.BalanceSheet.fromPartial(object.balances)
            : undefined;
        message.outpoint = (object.outpoint !== undefined && object.outpoint !== null)
            ? exports.Outpoint.fromPartial(object.outpoint)
            : undefined;
        message.output = (object.output !== undefined && object.output !== null)
            ? exports.Output.fromPartial(object.output)
            : undefined;
        message.height = object.height ?? 0;
        message.txindex = object.txindex ?? 0;
        return message;
    },
};
function createBasePaginationInput() {
    return { start: 0, end: 0 };
}
exports.PaginationInput = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.start !== 0) {
            writer.uint32(8).uint32(message.start);
        }
        if (message.end !== 0) {
            writer.uint32(16).uint32(message.end);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePaginationInput();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.start = reader.uint32();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.end = reader.uint32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            start: isSet(object.start) ? globalThis.Number(object.start) : 0,
            end: isSet(object.end) ? globalThis.Number(object.end) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.start !== 0) {
            obj.start = Math.round(message.start);
        }
        if (message.end !== 0) {
            obj.end = Math.round(message.end);
        }
        return obj;
    },
    create(base) {
        return exports.PaginationInput.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePaginationInput();
        message.start = object.start ?? 0;
        message.end = object.end ?? 0;
        return message;
    },
};
function createBaseWalletRequest() {
    return { wallet: new Uint8Array(0) };
}
exports.WalletRequest = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.wallet.length !== 0) {
            writer.uint32(10).bytes(message.wallet);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWalletRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.wallet = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { wallet: isSet(object.wallet) ? bytesFromBase64(object.wallet) : new Uint8Array(0) };
    },
    toJSON(message) {
        const obj = {};
        if (message.wallet.length !== 0) {
            obj.wallet = base64FromBytes(message.wallet);
        }
        return obj;
    },
    create(base) {
        return exports.WalletRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseWalletRequest();
        message.wallet = object.wallet ?? new Uint8Array(0);
        return message;
    },
};
function createBaseWalletResponse() {
    return { outpoints: [], balances: undefined };
}
exports.WalletResponse = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.outpoints) {
            exports.OutpointResponse.encode(v, writer.uint32(10).fork()).join();
        }
        if (message.balances !== undefined) {
            exports.BalanceSheet.encode(message.balances, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWalletResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.outpoints.push(exports.OutpointResponse.decode(reader, reader.uint32()));
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.balances = exports.BalanceSheet.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            outpoints: globalThis.Array.isArray(object?.outpoints)
                ? object.outpoints.map((e) => exports.OutpointResponse.fromJSON(e))
                : [],
            balances: isSet(object.balances) ? exports.BalanceSheet.fromJSON(object.balances) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.outpoints?.length) {
            obj.outpoints = message.outpoints.map((e) => exports.OutpointResponse.toJSON(e));
        }
        if (message.balances !== undefined) {
            obj.balances = exports.BalanceSheet.toJSON(message.balances);
        }
        return obj;
    },
    create(base) {
        return exports.WalletResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseWalletResponse();
        message.outpoints = object.outpoints?.map((e) => exports.OutpointResponse.fromPartial(e)) || [];
        message.balances = (object.balances !== undefined && object.balances !== null)
            ? exports.BalanceSheet.fromPartial(object.balances)
            : undefined;
        return message;
    },
};
function createBaseProtorunesWalletRequest() {
    return { wallet: new Uint8Array(0), protocolTag: undefined };
}
exports.ProtorunesWalletRequest = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.wallet.length !== 0) {
            writer.uint32(10).bytes(message.wallet);
        }
        if (message.protocolTag !== undefined) {
            exports.uint128.encode(message.protocolTag, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProtorunesWalletRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.wallet = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.protocolTag = exports.uint128.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            wallet: isSet(object.wallet) ? bytesFromBase64(object.wallet) : new Uint8Array(0),
            protocolTag: isSet(object.protocolTag) ? exports.uint128.fromJSON(object.protocolTag) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.wallet.length !== 0) {
            obj.wallet = base64FromBytes(message.wallet);
        }
        if (message.protocolTag !== undefined) {
            obj.protocolTag = exports.uint128.toJSON(message.protocolTag);
        }
        return obj;
    },
    create(base) {
        return exports.ProtorunesWalletRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseProtorunesWalletRequest();
        message.wallet = object.wallet ?? new Uint8Array(0);
        message.protocolTag = (object.protocolTag !== undefined && object.protocolTag !== null)
            ? exports.uint128.fromPartial(object.protocolTag)
            : undefined;
        return message;
    },
};
function createBaseRunesByHeightRequest() {
    return { height: 0n };
}
exports.RunesByHeightRequest = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.height !== 0n) {
            if (BigInt.asUintN(64, message.height) !== message.height) {
                throw new globalThis.Error("value provided for field message.height of type uint64 too large");
            }
            writer.uint32(8).uint64(message.height);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRunesByHeightRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.height = reader.uint64();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { height: isSet(object.height) ? BigInt(object.height) : 0n };
    },
    toJSON(message) {
        const obj = {};
        if (message.height !== 0n) {
            obj.height = message.height.toString();
        }
        return obj;
    },
    create(base) {
        return exports.RunesByHeightRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRunesByHeightRequest();
        message.height = object.height ?? 0n;
        return message;
    },
};
function createBaseRunesResponse() {
    return { runes: [] };
}
exports.RunesResponse = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.runes) {
            exports.Rune.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRunesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.runes.push(exports.Rune.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { runes: globalThis.Array.isArray(object?.runes) ? object.runes.map((e) => exports.Rune.fromJSON(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.runes?.length) {
            obj.runes = message.runes.map((e) => exports.Rune.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.RunesResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRunesResponse();
        message.runes = object.runes?.map((e) => exports.Rune.fromPartial(e)) || [];
        return message;
    },
};
function createBaseProtoBurn() {
    return { protocolTag: undefined, pointer: 0 };
}
exports.ProtoBurn = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.protocolTag !== undefined) {
            exports.uint128.encode(message.protocolTag, writer.uint32(10).fork()).join();
        }
        if (message.pointer !== 0) {
            writer.uint32(16).uint32(message.pointer);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProtoBurn();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.protocolTag = exports.uint128.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.pointer = reader.uint32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            protocolTag: isSet(object.protocolTag) ? exports.uint128.fromJSON(object.protocolTag) : undefined,
            pointer: isSet(object.pointer) ? globalThis.Number(object.pointer) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.protocolTag !== undefined) {
            obj.protocolTag = exports.uint128.toJSON(message.protocolTag);
        }
        if (message.pointer !== 0) {
            obj.pointer = Math.round(message.pointer);
        }
        return obj;
    },
    create(base) {
        return exports.ProtoBurn.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseProtoBurn();
        message.protocolTag = (object.protocolTag !== undefined && object.protocolTag !== null)
            ? exports.uint128.fromPartial(object.protocolTag)
            : undefined;
        message.pointer = object.pointer ?? 0;
        return message;
    },
};
function createBaseuint128() {
    return { lo: 0n, hi: 0n };
}
exports.uint128 = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.lo !== 0n) {
            if (BigInt.asUintN(64, message.lo) !== message.lo) {
                throw new globalThis.Error("value provided for field message.lo of type uint64 too large");
            }
            writer.uint32(8).uint64(message.lo);
        }
        if (message.hi !== 0n) {
            if (BigInt.asUintN(64, message.hi) !== message.hi) {
                throw new globalThis.Error("value provided for field message.hi of type uint64 too large");
            }
            writer.uint32(16).uint64(message.hi);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseuint128();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.lo = reader.uint64();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.hi = reader.uint64();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { lo: isSet(object.lo) ? BigInt(object.lo) : 0n, hi: isSet(object.hi) ? BigInt(object.hi) : 0n };
    },
    toJSON(message) {
        const obj = {};
        if (message.lo !== 0n) {
            obj.lo = message.lo.toString();
        }
        if (message.hi !== 0n) {
            obj.hi = message.hi.toString();
        }
        return obj;
    },
    create(base) {
        return exports.uint128.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseuint128();
        message.lo = object.lo ?? 0n;
        message.hi = object.hi ?? 0n;
        return message;
    },
};
function createBaseClause() {
    return { rune: undefined, amount: undefined };
}
exports.Clause = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.rune !== undefined) {
            exports.ProtoruneRuneId.encode(message.rune, writer.uint32(10).fork()).join();
        }
        if (message.amount !== undefined) {
            exports.uint128.encode(message.amount, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseClause();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.rune = exports.ProtoruneRuneId.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.amount = exports.uint128.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            rune: isSet(object.rune) ? exports.ProtoruneRuneId.fromJSON(object.rune) : undefined,
            amount: isSet(object.amount) ? exports.uint128.fromJSON(object.amount) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.rune !== undefined) {
            obj.rune = exports.ProtoruneRuneId.toJSON(message.rune);
        }
        if (message.amount !== undefined) {
            obj.amount = exports.uint128.toJSON(message.amount);
        }
        return obj;
    },
    create(base) {
        return exports.Clause.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseClause();
        message.rune = (object.rune !== undefined && object.rune !== null)
            ? exports.ProtoruneRuneId.fromPartial(object.rune)
            : undefined;
        message.amount = (object.amount !== undefined && object.amount !== null)
            ? exports.uint128.fromPartial(object.amount)
            : undefined;
        return message;
    },
};
function createBasePredicate() {
    return { clauses: [] };
}
exports.Predicate = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.clauses) {
            exports.Clause.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePredicate();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.clauses.push(exports.Clause.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            clauses: globalThis.Array.isArray(object?.clauses) ? object.clauses.map((e) => exports.Clause.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.clauses?.length) {
            obj.clauses = message.clauses.map((e) => exports.Clause.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.Predicate.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePredicate();
        message.clauses = object.clauses?.map((e) => exports.Clause.fromPartial(e)) || [];
        return message;
    },
};
function createBaseProtoMessage() {
    return { calldata: new Uint8Array(0), predicate: undefined, pointer: 0, refundPointer: 0 };
}
exports.ProtoMessage = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.calldata.length !== 0) {
            writer.uint32(10).bytes(message.calldata);
        }
        if (message.predicate !== undefined) {
            exports.Predicate.encode(message.predicate, writer.uint32(18).fork()).join();
        }
        if (message.pointer !== 0) {
            writer.uint32(24).uint32(message.pointer);
        }
        if (message.refundPointer !== 0) {
            writer.uint32(32).uint32(message.refundPointer);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProtoMessage();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.calldata = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.predicate = exports.Predicate.decode(reader, reader.uint32());
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.pointer = reader.uint32();
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.refundPointer = reader.uint32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            calldata: isSet(object.calldata) ? bytesFromBase64(object.calldata) : new Uint8Array(0),
            predicate: isSet(object.predicate) ? exports.Predicate.fromJSON(object.predicate) : undefined,
            pointer: isSet(object.pointer) ? globalThis.Number(object.pointer) : 0,
            refundPointer: isSet(object.refundPointer) ? globalThis.Number(object.refundPointer) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.calldata.length !== 0) {
            obj.calldata = base64FromBytes(message.calldata);
        }
        if (message.predicate !== undefined) {
            obj.predicate = exports.Predicate.toJSON(message.predicate);
        }
        if (message.pointer !== 0) {
            obj.pointer = Math.round(message.pointer);
        }
        if (message.refundPointer !== 0) {
            obj.refundPointer = Math.round(message.refundPointer);
        }
        return obj;
    },
    create(base) {
        return exports.ProtoMessage.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseProtoMessage();
        message.calldata = object.calldata ?? new Uint8Array(0);
        message.predicate = (object.predicate !== undefined && object.predicate !== null)
            ? exports.Predicate.fromPartial(object.predicate)
            : undefined;
        message.pointer = object.pointer ?? 0;
        message.refundPointer = object.refundPointer ?? 0;
        return message;
    },
};
function createBaseRuntimeInput() {
    return { protocolTag: undefined };
}
exports.RuntimeInput = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.protocolTag !== undefined) {
            exports.uint128.encode(message.protocolTag, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRuntimeInput();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.protocolTag = exports.uint128.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { protocolTag: isSet(object.protocolTag) ? exports.uint128.fromJSON(object.protocolTag) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.protocolTag !== undefined) {
            obj.protocolTag = exports.uint128.toJSON(message.protocolTag);
        }
        return obj;
    },
    create(base) {
        return exports.RuntimeInput.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRuntimeInput();
        message.protocolTag = (object.protocolTag !== undefined && object.protocolTag !== null)
            ? exports.uint128.fromPartial(object.protocolTag)
            : undefined;
        return message;
    },
};
function createBaseRuntime() {
    return { balances: undefined };
}
exports.Runtime = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.balances !== undefined) {
            exports.BalanceSheet.encode(message.balances, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRuntime();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.balances = exports.BalanceSheet.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { balances: isSet(object.balances) ? exports.BalanceSheet.fromJSON(object.balances) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.balances !== undefined) {
            obj.balances = exports.BalanceSheet.toJSON(message.balances);
        }
        return obj;
    },
    create(base) {
        return exports.Runtime.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRuntime();
        message.balances = (object.balances !== undefined && object.balances !== null)
            ? exports.BalanceSheet.fromPartial(object.balances)
            : undefined;
        return message;
    },
};
function createBaseProtorunesByHeightRequest() {
    return { height: 0n, protocolTag: undefined };
}
exports.ProtorunesByHeightRequest = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.height !== 0n) {
            if (BigInt.asUintN(64, message.height) !== message.height) {
                throw new globalThis.Error("value provided for field message.height of type uint64 too large");
            }
            writer.uint32(8).uint64(message.height);
        }
        if (message.protocolTag !== undefined) {
            exports.uint128.encode(message.protocolTag, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProtorunesByHeightRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.height = reader.uint64();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.protocolTag = exports.uint128.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            height: isSet(object.height) ? BigInt(object.height) : 0n,
            protocolTag: isSet(object.protocolTag) ? exports.uint128.fromJSON(object.protocolTag) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.height !== 0n) {
            obj.height = message.height.toString();
        }
        if (message.protocolTag !== undefined) {
            obj.protocolTag = exports.uint128.toJSON(message.protocolTag);
        }
        return obj;
    },
    create(base) {
        return exports.ProtorunesByHeightRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseProtorunesByHeightRequest();
        message.height = object.height ?? 0n;
        message.protocolTag = (object.protocolTag !== undefined && object.protocolTag !== null)
            ? exports.uint128.fromPartial(object.protocolTag)
            : undefined;
        return message;
    },
};
function bytesFromBase64(b64) {
    if (globalThis.Buffer) {
        return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    }
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) {
        return globalThis.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(globalThis.String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=protorune.js.map